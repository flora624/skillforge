[
  {
    "id": 1,
    "title": "AI RAG Chatbot with AWS Bedrock",
    "tagline": "Build an intelligent chatbot that answers questions based on your own documents, using Retrieval-Augmented Generation and serverless AWS services.",
    "domain": "Full-Stack + AI/ML",
    "difficulty": "Advanced",
    "estimatedHours": 80,
    "problemStatement": "Standard Large Language Models (LLMs) like ChatGPT have no knowledge of private, internal, or very recent documents. Businesses need a secure and cost-effective way to build chatbots that can provide accurate answers from their own knowledge base without the immense cost of retraining a foundational model.",
    "solution": "Construct a complete RAG pipeline. This involves creating a data ingestion script to process documents (e.g., PDFs) into a vector database like Pinecone. Then, build a Next.js application with a serverless backend on AWS Lambda that retrieves relevant context from this database to provide accurate, context-aware answers from an AWS Bedrock LLM (like Claude).",
    "skillsGained": [
      "Retrieval-Augmented Generation (RAG)",
      "Vector Databases (Pinecone)",
      "LLM Prompt Engineering",
      "AWS SDK Integration (Bedrock, S3, Lambda)",
      "Serverless Functions",
      "Real-time Data Streaming",
      "Document Processing (PDFs)",
      "Cloud Architecture"
    ],
    "techStack": [
      { "name": "Next.js", "type": "Framework" },
      { "name": "TypeScript", "type": "Language" },
      { "name": "AWS Bedrock", "type": "AI Service" },
      { "name": "AWS S3", "type": "File Storage" },
      { "name": "AWS Lambda", "type": "Serverless Compute" },
      { "name": "Pinecone", "type": "Vector Database" },
      { "name": "LangChain", "type": "AI Orchestration" },
      { "name": "Tailwind CSS", "type": "Styling" }
    ],
    "professionalPractices": {
      "ragPipeline": {
        "title": "RAG Pipeline Design",
        "description": "Understand the end-to-end flow of a production RAG system, from data ingestion and embedding to retrieval and final generation. This is a core pattern for building modern AI applications."
      },
      "serverlessArchitecture": {
        "title": "Serverless at Scale",
        "description": "Learn to leverage serverless functions (AWS Lambda) to build scalable, cost-effective backends that only run when needed, which is ideal for AI inference tasks."
      },
      "promptEngineering": {
        "title": "Advanced Prompt Engineering",
        "description": "Go beyond simple questions. Learn how to structure prompts that include retrieved context, instructing the LLM to ground its answers in specific facts, reducing hallucinations and improving accuracy."
      }
    },
    "milestones": [
      { "id": "m1_setup", "title": "Phase 1: Foundation & AWS Setup", "goal": "Set up your AWS account with the necessary permissions (IAM user), configure the AWS SDK in your local environment, and initialize the Next.js project.", "content": [ { "type": "paragraph", "value": "Before writing any application code, it's crucial to establish a secure and correctly configured cloud environment. This phase ensures your application can communicate with AWS services." }, { "type": "subheader", "value": "1. AWS Account and IAM User Setup" }, { "type": "paragraph", "value": "Create an AWS account if you don't have one. Create a new IAM (Identity and Access Management) user with programmatic access. Attach policies that grant access to Bedrock, S3, and Lambda. Securely save your access key and secret key." }, { "type": "callout", "style": "error", "value": "**Security Critical:** Never commit your AWS keys to Git. Use environment variables (`.env.local`) to store them securely." }, { "type": "code", "language": "bash", "value": "# .env.local\nAWS_ACCESS_KEY_ID=YOUR_ACCESS_KEY\nAWS_SECRET_ACCESS_KEY=YOUR_SECRET_KEY\nAWS_REGION=us-east-1 # Or your preferred region" }, { "type": "subheader", "value": "2. Project Initialization" }, { "type": "paragraph", "value": "Create a new Next.js project with TypeScript and install the necessary initial dependencies." }, { "type": "code", "language": "bash", "value": "npx create-next-app@latest ai-rag-chatbot --ts\ncd ai-rag-chatbot\nnpm install @aws-sdk/client-bedrock-runtime langchain ai" } ] },
      { "id": "m2_ingestion", "title": "Phase 2: Data Ingestion Pipeline", "goal": "Build a script that takes a source document (e.g., a PDF), loads it, splits it into chunks, creates embeddings for each chunk using an AI model, and stores them in a Pinecone vector database.", "content": [ { "type": "paragraph", "value": "This is the 'retrieval' part of RAG. We are preparing our knowledge base so the AI can search it later. We will use LangChain to simplify this process." }, { "type": "subheader", "value": "1. Set Up Pinecone" }, { "type": "paragraph", "value": "Create a free account on Pinecone. Create a new index, making sure to configure the correct 'dimensions' (e.g., 1536 for OpenAI's `text-embedding-ada-002`) for your embedding model." }, { "type": "subheader", "value": "2. Create the Ingestion Script" }, { "type": "paragraph", "value": "Write a Node.js script (`scripts/ingest.ts`) that uses LangChain to load a PDF, split it into smaller documents, generate embeddings, and upload them to your Pinecone index." }, { "type": "code", "language": "typescript", "value": "// scripts/ingest.ts (conceptual)\nimport { PDFLoader } from 'langchain/document_loaders/fs/pdf';\nimport { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';\nimport { PineconeStore } from 'langchain/vectorstores/pinecone';\nimport { OpenAIEmbeddings } from 'langchain/embeddings/openai';\nimport { pinecone } from '@/utils/pinecone-client';\n\n// Load PDF\nconst loader = new PDFLoader('docs/your-document.pdf');\nconst rawDocs = await loader.load();\n\n// Split text\nconst textSplitter = new RecursiveCharacterTextSplitter({ chunkSize: 1000 });\nconst docs = await textSplitter.splitDocuments(rawDocs);\n\n// Create and store embeddings\nconst embeddings = new OpenAIEmbeddings();\nconst index = pinecone.Index('your-index-name');\nawait PineconeStore.fromDocuments(docs, embeddings, {\n  pineconeIndex: index,\n  namespace: 'your-namespace',\n});" } ] },
      { "id": "m3_backend", "title": "Phase 3: Building the RAG Backend API", "goal": "Create a Next.js API route that receives a user's question, queries the Pinecone database for relevant context, constructs a detailed prompt, and calls AWS Bedrock to generate an answer.", "content": [ { "type": "paragraph", "value": "This is the core logic of the application. It connects the user's query to the knowledge base and the LLM." }, { "type": "subheader", "value": "1. Create the API Route" }, { "type": "paragraph", "value": "Set up a new API route in `pages/api/chat.ts`. This endpoint will handle the main RAG chain." }, { "type": "code", "language": "typescript", "value": "// pages/api/chat.ts (conceptual)\nimport { Bedrock } from 'langchain/llms/bedrock';\nimport { PineconeStore } from 'langchain/vectorstores/pinecone';\nimport { ConversationalRetrievalQAChain } from 'langchain/chains';\n\n// Initialize models and vector store\nconst model = new Bedrock({ model: 'anthropic.claude-v2' });\nconst vectorStore = await PineconeStore.fromExistingIndex(...);\n\n// Create the chain\nconst chain = ConversationalRetrievalQAChain.fromLLM(\n  model,\n  vectorStore.asRetriever(),\n  { returnSourceDocuments: true }\n);\n\n// Handle request\nconst response = await chain.call({ question: userQuery, chat_history: [] });\n// Send 'response.text' back to the client" } ] },
      { "id": "m4_frontend", "title": "Phase 4: Frontend Chat Interface & Streaming", "goal": "Build a clean chat interface using React. Implement logic to send user messages to your backend API and stream the response back in real-time for a smooth, ChatGPT-like user experience.", "content": [ { "type": "paragraph", "value": "A good user experience is critical. We'll use the Vercel AI SDK to make streaming responses from our serverless backend incredibly easy." }, { "type": "subheader", "value": "1. Implement the UI" }, { "type": "paragraph", "value": "Create the chat bubbles, input form, and message list components." }, { "type": "subheader", "value": "2. Use the `useChat` Hook" }, { "type": "paragraph", "value": "The Vercel AI SDK provides a `useChat` hook that handles all the complexity of state management, API calls, and streaming responses." }, { "type": "code", "language": "typescript", "value": "// app/page.tsx\n'use client';\nimport { useChat } from 'ai/react';\n\nexport default function Chat() {\n  const { messages, input, handleInputChange, handleSubmit } = useChat();\n\n  return (\n    <div>\n      {messages.map(m => (\n        <div key={m.id}><b>{m.role}:</b> {m.content}</div>\n      ))}\n\n      <form onSubmit={handleSubmit}>\n        <input value={input} onChange={handleInputChange} />\n        <button type=\"submit\">Send</button>\n      </form>\n    </div>\n  );\n}" } ] },
      { "id": "m5_deploy", "title": "Phase 5: Deployment & Final Polish", "goal": "Deploy the Next.js application to Vercel. Ensure environment variables for AWS, Pinecone, etc., are correctly configured in the Vercel project settings.", "content": [ { "type": "paragraph", "value": "Take your application live. Vercel automatically deploys API routes as serverless AWS Lambda functions, making the process seamless." }, { "type": "callout", "style": "info", "value": "**Professional Practice:** Set up a separate Pinecone index and AWS user for production vs. development to ensure your environments are isolated." } ] }
    ]
  },
  {
    "id": 2,
    "title": "Build a Simple Database from Scratch in Go",
    "tagline": "Implement a log-structured hash table-based key-value store, learning how databases work under the hood.",
    "domain": "Backend & Systems Engineering",
    "difficulty": "Advanced",
    "estimatedHours": 80,
    "problemStatement": "Developers frequently use databases like PostgreSQL or Redis, but their internal mechanisms are often a mystery. Building a simple database from scratch demystifies these concepts and provides a deep understanding of system design.",
    "solution": "Using Go, build a persistent key-value store inspired by Bitcask. The database will append all writes to a log file and use an in-memory hash map as an index to the byte offset of each key. Implement a compaction process to merge old log files and purge obsolete data.",
    "skillsGained": ["Low-Level File I/O", "Data Structures", "Database Internals", "Concurrency", "API Design", "Binary Data Encoding"],
    "techStack": [{"name": "Go (Golang)", "type": "Language"}, {"name": "Protocol Buffers", "type": "Serialization"}],
    "professionalPractices": {"logStructuredStorage": {"title": "Log-Structured Storage Design", "description": "Understand append-only logs for fast writes and simplified recovery."}, "inMemoryIndexing": {"title": "In-Memory Indexing", "description": "Learn the trade-offs of using an in-memory index for extremely fast reads."}, "compactionAndGarbageCollection": {"title": "Compaction", "description": "Grasp the essential database maintenance process of purging old data to reclaim disk space."}},
    "milestones": [
      {"id": "db_m1", "title": "Phase 1: The Append-Only Log", "goal": "Create the core storage engine that can append key-value pairs to a data file on disk.", "content": [ { "type": "paragraph", "value": "The simplest part of the database is writing data. We will define a clear on-disk format for each entry (e.g., timestamp, key size, value size, key, value) and write a function to append new entries to a file." }, { "type": "code", "language": "go", "value": "// Conceptual representation of an entry\ntype LogEntry struct {\n    Timestamp int64\n    Key       []byte\n    Value     []byte\n}\n\n// Writes a LogEntry to an io.Writer (the file)\nfunc (e *LogEntry) Encode(w io.Writer) error {\n    // ... logic to write sizes and data in binary format ...\n    return nil\n}" } ] },
      {"id": "db_m2", "title": "Phase 2: The In-Memory Index", "goal": "Implement an in-memory hash map that stores keys and their byte offsets in the log file. Create the 'Set' and 'Get' methods.", "content": [ { "type": "paragraph", "value": "The index is what makes reads fast. The `Set` operation will write to the log and then update the in-memory map. The `Get` operation will use the map to find the offset, then seek directly to that position in the file to read the value." }, { "type": "code", "language": "go", "value": "type DB struct {\n    index  map[string]int64 // Key -> file offset\n    file   *os.File\n    mu     sync.RWMutex\n}\n\nfunc (db *DB) Get(key string) ([]byte, error) {\n    db.mu.RLock()\n    defer db.mu.RUnlock()\n\n    offset, ok := db.index[key]\n    if !ok {\n        return nil, ErrKeyNotFound\n    }\n\n    // Seek to offset in db.file and read the value\n    // ... file reading logic ...\n    return value, nil\n}" } ] },
      {"id": "db_m3", "title": "Phase 3: Startup and Index Recovery", "goal": "Implement the logic to rebuild the in-memory index from the log file(s) when the database starts up.", "content": [ { "type": "paragraph", "value": "Since the index is in-memory, it's lost when the program closes. On startup, the database must read the entire log file from beginning to end, populating the hash map with the offset of the *last* seen value for each key." } ] },
      {"id": "db_m4", "title": "Phase 4: Compaction", "goal": "Implement a compaction process that merges multiple log files into a new, single log file containing only the most recent value for each key.", "content": [ { "type": "paragraph", "value": "Over time, the log file will contain many outdated values. Compaction is the garbage collection process. It iterates through all keys in the current index, reads their latest value from the old logs, and writes them to a new, clean log file. Once complete, the database can switch to using the new file and delete the old ones." } ] },
      {"id": "db_m5", "title": "Phase 5: Deletes and API Layer", "goal": "Implement a 'Delete' operation and wrap the database in a simple API (e.g., an HTTP server) for clients to use.", "content": [ { "type": "paragraph", "value": "A 'delete' in a log-structured system is just another write. You append a special 'tombstone' record for the key. During a `Get`, if the key points to a tombstone, you return 'Not Found'. The key and its tombstone are then fully removed during the next compaction." } ] }
    ]
  },
  {
    "id": 3,
    "title": "Real-time Data Streaming Pipeline with Kafka and Spark",
    "tagline": "Build a scalable pipeline to process a continuous stream of data in real-time, performing transformations and aggregations on the fly.",
    "domain": "Data Engineering",
    "difficulty": "Expert",
    "estimatedHours": 100,
    "problemStatement": "Traditional batch ETL is too slow for use cases like fraud detection or live analytics. A system is needed to ingest and process a high-throughput stream of events with very low latency.",
    "solution": "Simulate a stream of user click events with a Python producer publishing to Apache Kafka. Use Apache Spark Streaming to consume the stream, perform a stateful, windowed aggregation (e.g., clicks per user over 5 minutes), and write the results to an output. The entire system will run in Docker.",
    "skillsGained": ["Stream Processing", "Apache Kafka", "Apache Spark Streaming", "Distributed Systems", "Stateful Transformations", "Windowing Operations"],
    "techStack": [{"name": "Apache Kafka", "type": "Stream Platform"}, {"name": "Apache Spark", "type": "Computing Engine"}, {"name": "Python/Scala", "type": "Language"}, {"name": "Docker", "type": "Containerization"}],
    "professionalPractices": {"distributedMessageQueue": {"title": "Distributed Message Queues", "description": "Understand Kafka's fault-tolerant, persistent nature for reliable streaming."}, "structuredStreaming": {"title": "Structured Streaming Paradigm", "description": "Treat a data stream as a continuously appending table, enabling DataFrame-style operations."}, "statefulProcessing": {"title": "Stateful Stream Processing", "description": "Tackle the challenge of maintaining state over time using windowed aggregations and watermarking."}},
    "milestones": [
      {"id": "stream_m1", "title": "Phase 1: Infrastructure Setup", "goal": "Use Docker Compose to set up Kafka and Zookeeper, and create a Kafka topic.", "content": [ { "type": "paragraph", "value": "The foundation is a running Kafka cluster. We'll use a standard Docker Compose file for this, widely available online. After the containers are running, you'll execute a command inside the Kafka container to create the `click-events` topic." }, { "type": "code", "language": "bash", "value": "# Command to run inside the Kafka container\nkafka-topics.sh --create --topic click-events --bootstrap-server kafka:9092 --partitions 1 --replication-factor 1" } ] },
      {"id": "stream_m2", "title": "Phase 2: The Kafka Producer", "goal": "Write a Python script that simulates user click events (user_id, url, timestamp) and continuously sends them to the `click-events` Kafka topic.", "content": [ { "type": "paragraph", "value": "This script will generate our data stream. We'll use the `kafka-python` library to connect to the Kafka broker and publish messages." }, { "type": "code", "language": "python", "value": "from kafka import KafkaProducer\nimport json, time, random\n\nproducer = KafkaProducer(bootstrap_servers='localhost:9092', value_serializer=lambda v: json.dumps(v).encode('utf-8'))\n\nwhile True:\n    event = {'user_id': f'user_{random.randint(1, 10)}', 'url': '/product/123'}\n    producer.send('click-events', event)\n    time.sleep(0.5)" } ] },
      {"id": "stream_m3", "title": "Phase 3: The Spark Streaming Consumer", "goal": "Write a PySpark application that connects to Kafka, reads from the `click-events` topic, and displays the raw data to the console.", "content": [ { "type": "paragraph", "value": "This is the first step in our processing logic. We'll establish the connection between Spark and Kafka and ensure data is flowing correctly. This requires submitting the Spark job with the correct packages." }, { "type": "code", "language": "python", "value": "from pyspark.sql import SparkSession\n\nspark = SparkSession.builder.appName(\"ClickstreamProcessor\").getOrCreate()\n\n# Subscribe to the Kafka topic\ndf = spark.readStream \\\n    .format(\"kafka\") \\\n    .option(\"kafka.bootstrap.servers\", \"localhost:9092\") \\\n    .option(\"subscribe\", \"click-events\") \\\n    .load()\n\n# Print the raw value from Kafka to the console\nquery = df.selectExpr(\"CAST(value AS STRING)\").writeStream \\\n    .outputMode(\"append\") \\\n    .format(\"console\") \\\n    .start()\n\nquery.awaitTermination()" } ] },
      {"id": "stream_m4", "title": "Phase 4: Data Transformation and Aggregation", "goal": "Parse the JSON data and perform a windowed aggregation to count the number of clicks per user every 1 minute.", "content": [ { "type": "paragraph", "value": "This is the core stream processing logic. We will use Spark's Structured Streaming functions to define the schema, group the data, and perform a count over a tumbling window." }, { "type": "code", "language": "python", "value": "from pyspark.sql.functions import from_json, col, window\nfrom pyspark.sql.types import StructType, StructField, StringType\n\n# Define schema for the incoming JSON\nschema = StructType([StructField(\"user_id\", StringType())])\n\n# Parse the JSON string from Kafka\nparsed_df = df.select(from_json(col(\"value\").cast(\"string\"), schema).alias(\"data\"))\n\n# Perform a windowed count\nwindowed_counts = parsed_df.groupBy(\n    window(col(\"timestamp\"), \"1 minute\"),\n    col(\"data.user_id\")\n).count()\n\n# Write the aggregated counts to the console\nquery = windowed_counts.writeStream.outputMode(\"complete\").format(\"console\").start()" } ] },
      {"id": "stream_m5", "title": "Phase 5: Stateful Processing with Watermarking", "goal": "Add a watermark to the stream to allow the engine to drop old state, and change the aggregation to a sliding window.", "content": [ { "type": "paragraph", "value": "A simple windowed count will keep state in memory forever. Watermarking tells Spark how late data can be before it's ignored, allowing the engine to safely clean up old state. This is a critical concept for robust, long-running stream jobs." }, { "type": "code", "language": "python", "value": "# Add a watermark of 2 minutes\nparsed_df_with_watermark = parsed_df.withWatermark(\"timestamp\", \"2 minutes\")\n\n# Change to a sliding window: 5 min window, sliding every 1 min\nsliding_window_counts = parsed_df_with_watermark.groupBy(\n    window(col(\"timestamp\"), \"5 minutes\", \"1 minute\"),\n    col(\"data.user_id\")\n).count()" } ] }
    ]
  },
  {
    "id": 4,
    "title": "CI/CD Pipeline for a Web App with Terraform & GitHub Actions",
    "tagline": "Automate the testing, building, and deployment of a web application to the cloud using professional DevOps practices.",
    "domain": "DevOps & Cloud Engineering",
    "difficulty": "Advanced",
    "estimatedHours": 70,
    "problemStatement": "Manually deploying applications is slow, error-prone, and not scalable. An automated process is needed to ensure every code change is tested and safely deployed to production.",
    "solution": "Define cloud infrastructure (S3, CloudFront) using Terraform. Create a GitHub Actions workflow that triggers on push to `main`. The workflow will install dependencies, run tests, build the application, and deploy the artifacts to the S3 bucket provisioned by Terraform.",
    "skillsGained": ["CI/CD", "GitHub Actions", "Infrastructure as Code (IaC)", "Terraform", "AWS S3 & CloudFront", "Automated Testing", "Secrets Management"],
    "techStack": [{"name": "GitHub Actions", "type": "CI/CD"}, {"name": "Terraform", "type": "IaC"}, {"name": "AWS", "type": "Cloud"}, {"name": "Docker", "type": "Containerization"}],
    "professionalPractices": {"infrastructureAsCode": {"title": "Infrastructure as Code (IaC)", "description": "Manage infrastructure using version-controlled files to ensure consistency and prevent configuration drift."}, "gitTriggeredWorkflows": {"title": "Git-Triggered Workflows", "description": "Adopt a professional Git workflow where merges trigger automated validation and deployment pipelines."}, "secretsManagement": {"title": "Secure Secrets Management", "description": "Handle sensitive credentials securely within a CI/CD environment using encrypted secrets."}},
    "milestones": [
      {"id": "cicd_m1", "title": "Phase 1: Infrastructure as Code", "goal": "Write Terraform code to provision an S3 bucket for static website hosting and a CloudFront distribution for CDN access.", "content": [ { "type": "paragraph", "value": "This phase treats infrastructure as code. You'll define the desired state of your AWS resources in HCL (HashiCorp Configuration Language)." }, { "type": "code", "language": "hcl", "value": "provider \"aws\" {\n  region = \"us-east-1\"\n}\n\nresource \"aws_s3_bucket\" \"site\" {\n  bucket = \"my-unique-cicd-bucket-name-12345\"\n}\n\nresource \"aws_s3_bucket_website_configuration\" \"site_config\" {\n  bucket = aws_s3_bucket.site.id\n  index_document {\n    suffix = \"index.html\"\n  }\n}" }, { "type": "paragraph", "value": "Run `terraform init`, `terraform plan`, and `terraform apply` to provision the resources in your AWS account." } ] },
      {"id": "cicd_m2", "title": "Phase 2: Build & Test Workflow", "goal": "Create a GitHub Actions workflow that checks out code, installs dependencies, runs tests, and builds a sample React app.", "content": [ { "type": "paragraph", "value": "This is the 'Continuous Integration' part. Create a file `.github/workflows/deploy.yml`." }, { "type": "code", "language": "yaml", "value": "name: Deploy Website\non:\n  push:\n    branches: [ main ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Use Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18.x'\n      - run: npm ci\n      - run: npm test\n      - run: npm run build" } ] },
      {"id": "cicd_m3", "title": "Phase 3: Secure Deployment", "goal": "Add steps to the workflow to securely configure AWS credentials and sync the build output to S3.", "content": [ { "type": "paragraph", "value": "This is the 'Continuous Deployment' part. You must first add your AWS credentials as encrypted secrets in your GitHub repository settings under 'Secrets and variables > Actions'." }, { "type": "callout", "style": "error", "value": "**Security Critical:** Add `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` as repository secrets. Never hardcode them." }, { "type": "code", "language": "yaml", "value": "# Add these steps to the build job\n      - name: Configure AWS Credentials\n        uses: aws-actions/configure-aws-credentials@v2\n        with:\n          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n          aws-region: us-east-1\n\n      - name: Deploy to S3\n        run: aws s3 sync ./build s3://my-unique-cicd-bucket-name-12345 --delete" } ] },
      {"id": "cicd_m4", "title": "Phase 4: Cache Invalidation", "goal": "Add a final step to invalidate the CloudFront cache to ensure users see the latest version immediately after deployment.", "content": [ { "type": "paragraph", "value": "Deploying new files to S3 isn't enough if a CDN is caching the old ones. The final step is to tell CloudFront to clear its cache." }, { "type": "code", "language": "yaml", "value": "# Add as the final step in the job\n      - name: Invalidate CloudFront Cache\n        run: aws cloudfront create-invalidation --distribution-id YOUR_CLOUDFRONT_ID --paths \"/*\"" } ] }
    ]
  },
  {
    "id": 5,
    "title": "Launch a New Feature for a Mock SaaS App",
    "tagline": "Drive a new feature from idea to launch by conducting user research, defining requirements, creating a GTM strategy, and analyzing success.",
    "domain": "Product Management",
    "difficulty": "Intermediate",
    "estimatedHours": 50,
    "problemStatement": "A hypothetical SaaS company is experiencing high user churn due to a complex interface. A new, simplified 'Dashboard' feature is needed to improve user onboarding and engagement.",
    "solution": "Act as the Product Manager. Conduct user interviews, write a PRD with user stories in Jira, create wireframes, develop a phased rollout plan and GTM strategy, and define a KPI dashboard to track success post-launch.",
    "skillsGained": ["Product Requirements (PRD)", "User Story Creation", "Roadmapping", "User Research", "Go-To-Market (GTM) Strategy", "KPI Definition & Analysis"],
    "techStack": [{"name": "Jira", "type": "PM Tool"}, {"name": "Confluence", "type": "Docs"}, {"name": "Figma", "type": "Wireframing"}, {"name": "Mixpanel", "type": "Analytics"}],
    "professionalPractices": {"problemFirstThinking": {"title": "Problem-First Thinking", "description": "Deeply understand and validate the user's problem through research before designing solutions."}, "stakeholderCommunication": {"title": "Stakeholder Communication", "description": "Practice writing clear specs for engineers and presenting the business case to leadership."}, "dataDrivenDecisionMaking": {"title": "Data-Driven Decisions", "description": "Define measurable success metrics upfront and use analytics to determine if your feature achieved its goals."}},
    "milestones": [
      {"id": "pm_m1", "title": "Phase 1: Research and Validation", "goal": "Conduct user interviews and synthesize feedback to validate the core problem.", "content": [ { "type": "paragraph", "value": "This phase is about confirming you are solving a real problem. You'll create user personas and an interview script." }, { "type": "callout", "style": "info", "value": "Use a tool like Miro to create an affinity map of interview feedback, grouping similar comments to find patterns." } ] },
      {"id": "pm_m2", "title": "Phase 2: Specification", "goal": "Write a clear Product Requirements Document (PRD) in Confluence and break it down into actionable user stories in Jira.", "content": [ { "type": "paragraph", "value": "Translate user needs into engineering requirements. The PRD should define goals, non-goals, and success metrics (e.g., increase in 7-day retention)." }, { "type": "code", "language": "text", "value": "As a [Project Manager], I want to [see all overdue tasks on the dashboard], so that I can [prioritize my day]." } ] },
      {"id": "pm_m3", "title": "Phase 3: Design and Roadmapping", "goal": "Create low-fidelity wireframes in Figma and a phased rollout plan for the feature.", "content": [ { "type": "paragraph", "value": "Visualize the solution and plan its delivery. Use a framework like MoSCoW (Must-have, Should-have, Could-have, Won't-have) to prioritize features for the V1 launch." } ] },
      {"id": "pm_m4", "title": "Phase 4: Go-To-Market Strategy", "goal": "Create a GTM plan detailing the launch messaging, channels (email, in-app notifications, blog post), and documentation.", "content": [ { "type": "paragraph", "value": "Building a great feature is only half the battle; users need to know it exists. Your plan should clearly define the target audience and the key message for each channel." } ] },
      {"id": "pm_m5", "title": "Phase 5: Post-Launch Analysis", "goal": "Create a KPI dashboard mockup and a report template to analyze the feature's success against the goals defined in the PRD.", "content": [ { "type": "paragraph", "value": "The product lifecycle doesn't end at launch. This final deliverable demonstrates your ability to learn from data and propose next steps for iteration." } ] }
    ]
  },
  {
    "id": 6,
    "title": "Redesign a Mobile App for Accessibility & Usability",
    "tagline": "Transform a poorly designed mobile app into an accessible, intuitive, and visually appealing experience through a complete UX/UI design process.",
    "domain": "UX/UI Design",
    "difficulty": "Intermediate",
    "estimatedHours": 60,
    "problemStatement": "Many applications suffer from poor usability, cluttered interfaces, and a lack of accessibility. A hypothetical local transit app, 'CityGo', is functional but difficult to navigate, especially for users with impairments.",
    "solution": "Conduct a full redesign of the 'CityGo' app. Start with a heuristic evaluation, create user personas and journey maps, develop new user flows and wireframes, and build a high-fidelity, interactive prototype in Figma that adheres to WCAG standards. Validate the design with usability testing.",
    "skillsGained": ["User Research", "Heuristic Evaluation", "User Journey Mapping", "Wireframing & Prototyping", "High-Fidelity UI Design", "Accessibility (WCAG)"],
    "techStack": [{"name": "Figma", "type": "Design"}, {"name": "Miro", "type": "Collaboration"}, {"name": "Maze", "type": "Testing"}, {"name": "WCAG Guidelines", "type": "Standard"}],
    "professionalPractices": {"humanCenteredDesign": {"title": "Human-Centered Design", "description": "Practice the full design thinking process: empathize, define, ideate, prototype, and test."}, "accessibilityFirst": {"title": "Accessibility-First Design", "description": "Design for inclusivity, considering color contrast, touch target sizes, and screen reader compatibility."}, "iterativeProcess": {"title": "The Iterative Design Process", "description": "Demonstrate the ability to take feedback from usability tests and iterate on your designs to improve the user experience."}},
    "milestones": [
      {"id": "ux_m1", "title": "Phase 1: Discovery and Research", "goal": "Conduct a heuristic evaluation and competitive analysis of an existing, poorly-rated transit app.", "content": [ { "type": "paragraph", "value": "You can't fix a problem without understanding it. Find a real-world app to serve as your 'before' example and document its flaws against Nielsen's 10 Heuristics." } ] },
      {"id": "ux_m2", "title": "Phase 2: Define and Ideate", "goal": "Create user journey maps and new, streamlined user flows for key tasks (e.g., 'plan a trip').", "content": [ { "type": "paragraph", "value": "This phase bridges the gap between 'what's wrong' and 'how we can fix it'. Use Miro to visually map out the current frustrating journey and the ideal future-state journey." } ] },
      {"id": "ux_m3", "title": "Phase 3: Design and Prototype", "goal": "Create wireframes, a simple design system, and a high-fidelity interactive prototype in Figma.", "content": [ { "type": "paragraph", "value": "This is where the new design takes visual form. Start with low-fidelity wireframes focusing on layout, then create a design system (colors, typography) and build the high-fidelity, clickable prototype." }, { "type": "callout", "style": "info", "value": "Use Figma's 'Prototype' mode to link your screens together, creating a realistic user flow." } ] },
      {"id": "ux_m4", "title": "Phase 4: Usability Testing", "goal": "Test the prototype with real users to gather feedback and identify pain points.", "content": [ { "type": "paragraph", "value": "This step validates your design choices. Create a test plan with specific tasks and recruit 3-5 users. You can use a tool like Maze for unmoderated testing or conduct live tests over video call." } ] },
      {"id": "ux_m5", "title": "Phase 5: Iterate and Case Study", "goal": "Revise the prototype based on feedback and compile the project into a compelling portfolio case study.", "content": [ { "type": "paragraph", "value": "The final deliverable. Create a portfolio piece (e.g., on Behance) that walks through each phase of this project. Clearly show the 'before' and 'after', explain your design rationale with data, and highlight how user feedback informed your final design." } ] }
    ]
  },
  {
    "id": 7,
    "title": "Develop and Backtest a Quantitative Trading Strategy",
    "tagline": "Use Python and historical market data to design, implement, and rigorously test a quantitative trading strategy, analyzing its performance.",
    "domain": "Finance & Quantitative Analysis",
    "difficulty": "Intermediate",
    "estimatedHours": 50,
    "problemStatement": "Trading ideas must be tested against historical data to determine their statistical performance (profitability, risk) before deploying real capital. This process, backtesting, is fundamental to quantitative finance.",
    "solution": "Develop a Python backtesting engine in a Jupyter Notebook. Use `yfinance` to fetch historical data. Implement a 'Dual Moving Average Crossover' strategy, generate buy/sell signals, simulate a portfolio, and calculate key performance metrics like total return, Sharpe ratio, and maximum drawdown.",
    "skillsGained": ["Quantitative Analysis", "Algorithmic Trading", "Backtesting", "Financial Data Analysis (Pandas)", "Performance Metrics (Sharpe Ratio)"],
    "techStack": [{"name": "Python", "type": "Language"}, {"name": "Pandas", "type": "Data Analysis"}, {"name": "Matplotlib", "type": "Plotting"}, {"name": "Jupyter Notebook", "type": "IDE"}],
    "professionalPractices": {"rigorousBacktesting": {"title": "Rigorous Backtesting", "description": "Learn to test a trading hypothesis against historical data, avoiding common pitfalls like lookahead bias."}, "riskAndReturnAnalysis": {"title": "Risk and Return Analysis", "description": "Calculate and interpret professional risk-adjusted return metrics like the Sharpe ratio."}, "reproducibleResearch": {"title": "Reproducible Research", "description": "Present your methodology and findings in a clean, commented Jupyter Notebook."}},
    "milestones": [
      {"id": "quant_m1", "title": "Phase 1: Data Acquisition", "goal": "Fetch several years of daily historical price data for a major stock (e.g., AAPL or SPY) using the `yfinance` library.", "content": [ { "type": "paragraph", "value": "The foundation of any quantitative analysis is clean, reliable data." }, { "type": "code", "language": "python", "value": "import yfinance as yf\n\n# Fetch data for the S&P 500 ETF\ndata = yf.download('SPY', start='2010-01-01', end='2023-12-31')\nprint(data.head())" } ] },
      {"id": "quant_m2", "title": "Phase 2: Strategy Implementation", "goal": "Calculate the short-term (e.g., 50-day) and long-term (e.g., 200-day) simple moving averages (SMA) and generate trading signals.", "content": [ { "type": "paragraph", "value": "This is where we codify the trading logic. A 'buy' signal is generated when the short-term SMA crosses above the long-term SMA." }, { "type": "code", "language": "python", "value": "data['short_mavg'] = data['Close'].rolling(window=50).mean()\ndata['long_mavg'] = data['Close'].rolling(window=200).mean()\n\ndata['signal'] = 0.0\ndata.loc[data['short_mavg'] > data['long_mavg'], 'signal'] = 1.0\n\ndata['positions'] = data['signal'].diff()" } ] },
      {"id": "quant_m3", "title": "Phase 3: Backtesting Engine", "goal": "Simulate the performance of a portfolio that follows the trading signals. Start with an initial capital and track its value over time.", "content": [ { "type": "paragraph", "value": "This step translates abstract signals into a concrete equity curve. We'll create a portfolio that is 100% invested following a 'buy' signal and 100% in cash following a 'sell' signal." }, { "type": "code", "language": "python", "value": "import numpy as np\n\ninitial_capital = 100000.0\npositions = pd.DataFrame(index=data.index).fillna(0.0)\npositions['SPY'] = 100 * data['signal']   # Each signal buys 100 shares\n\nportfolio = positions.multiply(data['Close'], axis=0)\npos_diff = positions.diff()\n\nportfolio['holdings'] = (positions.multiply(data['Close'], axis=0)).sum(axis=1)\nportfolio['cash'] = initial_capital - (pos_diff.multiply(data['Close'], axis=0)).sum(axis=1).cumsum()\n\nportfolio['total'] = portfolio['cash'] + portfolio['holdings']\nportfolio['returns'] = portfolio['total'].pct_change()" } ] },
      {"id": "quant_m4", "title": "Phase 4: Performance Analysis", "goal": "Calculate and visualize key performance metrics like Sharpe ratio and maximum drawdown, and compare against a 'buy and hold' strategy.", "content": [ { "type": "paragraph", "value": "A raw number for total profit isn't enough. We need to understand the risk-adjusted return and visualize the results." }, { "type": "code", "language": "python", "value": "# Sharpe Ratio\nsharpe_ratio = np.sqrt(252) * (portfolio['returns'].mean() / portfolio['returns'].std()) # Annualized\n\n# Max Drawdown\nwealth_index = portfolio['total']\nprevious_peaks = wealth_index.cummax()\ndrawdown = (wealth_index - previous_peaks) / previous_peaks\nmax_drawdown = drawdown.min()\n\nprint(f'Sharpe Ratio: {sharpe_ratio:.2f}')\nprint(f'Max Drawdown: {max_drawdown:.2%}')" } ] }
    ]
  },
  {
    "id": 8,
    "title": "Design and 3D Print a Custom Drone Frame",
    "tagline": "Engineer a lightweight, durable drone frame from concept to physical prototype using CAD, finite element analysis, and 3D printing.",
    "domain": "Mechanical Engineering",
    "difficulty": "Advanced",
    "estimatedHours": 70,
    "problemStatement": "Off-the-shelf drone frames are generic and not optimized for specific payloads or components. A custom-built frame is needed that balances strength, weight, and functionality.",
    "solution": "Define requirements (motor size, weight). Create a 3D model of the frame in SolidWorks or Fusion 360. Perform a simplified Finite Element Analysis (FEA) to simulate stress and identify weak points. Iteratively refine the design for strength and printability, then slice and print a physical prototype.",
    "skillsGained": ["3D CAD Modeling", "Finite Element Analysis (FEA)", "Design for Additive Manufacturing (DFAM)", "Material Selection", "Prototyping"],
    "techStack": [{"name": "SolidWorks / Fusion 360", "type": "CAD"}, {"name": "ANSYS", "type": "FEA"}, {"name": "Ultimaker Cura", "type": "Slicer"}, {"name": "FDM 3D Printer", "type": "Manufacturing"}],
    "professionalPractices": {"requirementsDrivenDesign": {"title": "Requirements-Driven Design", "description": "Start every project by defining constraints and requirements that guide all design decisions."}, "designForManufacturability": {"title": "Design for Manufacturability", "description": "Design parts that can be manufactured reliably, minimizing overhangs and optimizing layer orientation."}, "simulationInformedIteration": {"title": "Simulation-Informed Iteration", "description": "Use simulation (FEA) as a tool to inform the design process, not just for final validation."}},
    "milestones": [
      {"id": "mech_m1", "title": "Phase 1: Requirements and Component Modeling", "goal": "Define project requirements and create simplified 3D models of core electronic components (motors, flight controller).", "content": [ { "type": "paragraph", "value": "A good frame is designed around its components. Start by modeling these components (or downloading them from GrabCAD) to ensure your frame has correct mounting holes and clearances." } ] },
      {"id": "mech_m2", "title": "Phase 2: Initial Frame Design (CAD)", "goal": "Design the first version of the drone frame in Fusion 360, including the main body and arms, ensuring all components fit correctly within an assembly.", "content": [ { "type": "callout", "style": "info", "value": "Pay close attention to creating correct constraints and fully defined sketches in your CAD software. This is a core professional practice." } ] },
      {"id": "mech_m3", "title": "Phase 3: Stress Analysis (FEA)", "goal": "Perform a static stress analysis to simulate forces during a hard landing and identify high-stress areas.", "content": [ { "type": "paragraph", "value": "This is where we test the design digitally. Apply fixed constraints and apply forces to the motor mounts. Analyze the resulting stress plot (von Mises) and iterate on the design to strengthen weak points." } ] },
      {"id": "mech_m4", "title": "Phase 4: Slicing and Printing", "goal": "Optimize the final design for 3D printing, slice it in Cura, and print a physical prototype.", "content": [ { "type": "paragraph", "value": "This phase bridges the digital and physical worlds. Pay close attention to print orientation to maximize layer strength." } ] },
      {"id": "mech_m5", "title": "Phase 5: Evaluation and Report", "goal": "Test-fit components, evaluate the prototype's strength, and create a final design report with CAD drawings and FEA results.", "content": [ { "type": "paragraph", "value": "The project concludes with verifying the physical object against the initial requirements and documenting the process in a professional report." } ] }
    ]
  },
  {
    "id": 9,
    "title": "Build a Custom PCB for an IoT Weather Station",
    "tagline": "Design a professional printed circuit board (PCB) from schematic to manufactured board to house an ESP32-based weather monitoring device.",
    "domain": "Electrical Engineering",
    "difficulty": "Advanced",
    "estimatedHours": 65,
    "problemStatement": "Breadboards are great for prototyping but are unreliable and messy. To create a robust, compact electronic device, a custom-designed PCB is essential.",
    "solution": "Design a complete PCB for a weather station. Select components (ESP32, BME280 sensor). Create a circuit schematic in KiCad or Eagle. Design the physical PCB layout, placing components and routing traces. Generate Gerber files and send them to a PCB fabrication service. Finally, solder the components and program the device.",
    "skillsGained": ["Schematic Capture", "PCB Layout & Routing", "Component Selection", "Design for Manufacturability (DFM)", "Gerber Generation", "SMD Soldering"],
    "techStack": [{"name": "KiCad / Autodesk Eagle", "type": "EDA"}, {"name": "ESP32", "type": "MCU"}, {"name": "JLCPCB", "type": "Manufacturing"}, {"name": "Soldering Iron", "type": "Tool"}],
    "professionalPractices": {"schematicToLayoutWorkflow": {"title": "Schematic-to-Layout Workflow", "description": "Master the fundamental EE workflow of defining logical connections before physical design."}, "designRulesAndConstraints": {"title": "Design Rules and Constraints", "description": "Learn to work with a manufacturer's design rules and run a Design Rule Check (DRC)."}, "signalIntegrity": {"title": "Signal Integrity", "description": "Practice good layout techniques like using ground planes and decoupling capacitors."}},
    "milestones": [
      {"id": "ee_m1", "title": "Phase 1: Schematic Capture", "goal": "Create a complete circuit schematic in KiCad, connecting all components logically and running an Electrical Rules Check (ERC).", "content": [ { "type": "paragraph", "value": "This is the blueprint of your circuit. You'll import symbols for your ESP32 module, BME280 sensor, a voltage regulator, and passive components, then wire them together." } ] },
      {"id": "ee_m2", "title": "Phase 2: PCB Layout and Component Placement", "goal": "Design the physical board layout. Assign footprints to schematic symbols and strategically place them on the board.", "content": [ { "type": "paragraph", "value": "Good placement is key: place mounting holes first, then connectors, then ICs. Place decoupling capacitors as close as possible to the ICs they support." } ] },
      {"id": "ee_m3", "title": "Phase 3: Routing Traces and Ground Planes", "goal": "Route the copper traces to connect the component pads according to the schematic's netlist. Create a ground plane.", "content": [ { "type": "paragraph", "value": "This is like solving a puzzle. Use different layers (top and bottom) and then create a large 'copper pour' connected to ground to improve signal integrity." } ] },
      {"id": "ee_m4", "title": "Phase 4: Design Checks and Fabrication", "goal": "Run a final Design Rule Check (DRC) against your manufacturer's specs, generate Gerber and drill files, and order the board from a service like JLCPCB.", "content": [ { "type": "paragraph", "value": "This is the final sign-off before manufacturing. The DRC will check your layout against your manufacturer's capabilities (e.g., minimum trace width, clearance)." } ] },
      {"id": "ee_m5", "title": "Phase 5: Assembly, Testing, and Programming", "goal": "Solder all the components onto the manufactured PCB, test for shorts with a multimeter, and flash the firmware.", "content": [ { "type": "paragraph", "value": "The physical creation. You will carefully solder each component, starting with the smallest surface-mount parts. If all is clear after testing, connect power and upload your weather station code." } ] }
    ]
  },
  {
    "id": 10,
    "title": "Develop an SEO & Content Strategy for a Niche Business",
    "tagline": "Drive organic traffic growth from zero by performing keyword research, creating optimized content, and tracking performance for a fictional niche website.",
    "domain": "Digital Marketing",
    "difficulty": "Intermediate",
    "estimatedHours": 40,
    "problemStatement": "A new online business has great content but no visibility on search engines. They need a comprehensive SEO and content strategy to attract their target audience organically.",
    "solution": "Act as the digital marketer for a fictional business. Use SEO tools for keyword research. Create a content calendar and write 3-5 high-quality, long-form blog posts optimized for target keywords. Perform on-page SEO. Create a report using Google Analytics and Google Search Console to track impressions, clicks, and rankings.",
    "skillsGained": ["SEO", "Keyword Research", "Content Strategy", "On-Page SEO", "Google Analytics", "Google Search Console"],
    "techStack": [{"name": "Google Analytics", "type": "Analytics"}, {"name": "Google Search Console", "type": "SEO Tool"}, {"name": "Ahrefs/SEMrush", "type": "Research"}, {"name": "WordPress/Ghost", "type": "CMS"}],
    "professionalPractices": {"topicClusters": {"title": "Topic Clusters", "description": "Learn the modern SEO strategy of building authority with 'pillar' and 'cluster' content."}, "searchIntent": {"title": "Understanding Search Intent", "description": "Analyze search results to understand what users are really looking for and tailor your content to meet that intent."}, "metricsDrivenOptimization": {"title": "Metrics-Driven Optimization", "description": "Use data from GSC to find opportunities, like improving content that ranks on page 2."}},
    "milestones": [
      {"id": "seo_m1", "title": "Phase 1: Keyword and Competitive Research", "goal": "Identify a set of target keywords and analyze the top-ranking content for those keywords.", "content": [ { "type": "paragraph", "value": "Strategy starts with data. You'll define your niche (e.g., 'sustainable pet ownership') and find what people are searching for using free keyword tools. Analyze the top 10 results for your main keywords to understand search intent." } ] },
      {"id": "seo_m2", "title": "Phase 2: Content Strategy and Calendar", "goal": "Create a content plan based on a topic cluster model, organized as a content calendar in a spreadsheet.", "content": [ { "type": "paragraph", "value": "Turn your research into an actionable plan. Choose a broad, high-volume keyword for your 'pillar' page and several long-tail keywords for your 'cluster' posts." } ] },
      {"id": "seo_m3", "title": "Phase 3: Content Creation and On-Page SEO", "goal": "Write and publish 2-3 of the planned blog posts, ensuring they are well-written and optimized for search engines.", "content": [ { "type": "paragraph", "value": "Execute the plan. Write a 1000+ word article, ensuring the target keyword is in the URL, title tag, meta description, and H1. Use internal links to connect your pillar and cluster content." } ] },
      {"id": "seo_m4", "title": "Phase 4: Analytics Setup and Tracking", "goal": "Set up Google Analytics and Google Search Console for your website and submit a sitemap.", "content": [ { "type": "paragraph", "value": "You can't improve what you don't measure. This step sets up the essential free tools for tracking SEO success." } ] },
      {"id": "seo_m5", "title": "Phase 5: Performance Reporting and Analysis", "goal": "After a few weeks, create a report that analyzes the initial performance of your content and outlines next steps.", "content": [ { "type": "paragraph", "value": "Analyze metrics from GSC: impressions, clicks, CTR, and average position. Propose optimizations based on the data (e.g., 'This post has high impressions but low CTR, so I will improve the title tag')." } ] }
    ]
  },
  {
    "id": 11,
    "title": "Build a Simple Compiler from Scratch",
    "tagline": "Create a compiler for a simple C-like language that transforms source code into executable assembly.",
    "domain": "Systems Engineering",
    "difficulty": "Expert",
    "estimatedHours": 120,
    "problemStatement": "Understanding how high-level code becomes machine-executable instructions is a fundamental computer science skill. Building a compiler demystifies the process of lexical analysis, parsing, and code generation.",
    "solution": "Using a language like C++ or Rust, build a multi-stage compiler. It will include a lexer to tokenize the input, a parser to build an Abstract Syntax Tree (AST), and a code generator that traverses the AST to emit x86-64 assembly code. The language will support variables, basic arithmetic, and functions.",
    "skillsGained": ["Compiler Design", "Lexical Analysis", "Parsing", "Abstract Syntax Tree (AST)", "Code Generation", "Assembly Language (x86-64)"],
    "techStack": [{"name": "C++/Rust", "type": "Language"}, {"name": "Flex/Bison (Optional)", "type": "Tools"}, {"name": "NASM/GCC", "type": "Assembler/Linker"}],
    "professionalPractices": {"separationOfConcerns": {"title": "Separation of Concerns", "description": "Clearly separate the lexer, parser, and code generator, a core principle of compiler architecture."}, "astRepresentation": {"title": "AST Representation", "description": "Learn how to effectively model source code structure in a tree data format."}, "registerAllocation": {"title": "Register Allocation", "description": "Tackle the challenge of efficiently using CPU registers to store variables and intermediate results."}},
    "milestones": [
      {"id": "comp_m1", "title": "Phase 1: The Lexer (Tokenizer)", "goal": "Implement a lexical analyzer to convert a stream of source code characters into a stream of tokens (e.g., NUMBER, IDENTIFIER, PLUS).", "content": [ { "type": "paragraph", "value": "This is the first stage of any compiler. It breaks the raw text into meaningful chunks." } ] },
      {"id": "comp_m2", "title": "Phase 2: The Parser and AST", "goal": "Implement a recursive descent parser to build an Abstract Syntax Tree (AST) from the token stream. This tree represents the code's structure.", "content": [ { "type": "paragraph", "value": "The parser checks for correct syntax and creates a tree structure. For example, `4 + 5` becomes a `+` node with `4` and `5` as children." } ] },
      {"id": "comp_m3", "title": "Phase 3: Code Generation for Expressions", "goal": "Traverse the AST to generate corresponding x86-64 assembly code for basic arithmetic expressions.", "content": [ { "type": "code", "language": "nasm", "value": "; Code for the expression 5 - 2\nmov rax, 5\nmov rbx, 2\nsub rax, rbx" } ] },
      {"id": "comp_m4", "title": "Phase 4: Functions and Variables", "goal": "Extend the compiler to handle function definitions, calls, and local variable storage on the stack.", "content": [ { "type": "paragraph", "value": "This involves managing the stack frame, allocating space for local variables, and implementing call/ret instructions." } ] }
    ]
  },
  {
    "id": 12,
    "title": "Deploy a Honeypot and Analyze Attack Data",
    "tagline": "Set up a decoy system to attract and analyze real-world cyberattacks, gathering threat intelligence on attacker methods and origins.",
    "domain": "Cybersecurity",
    "difficulty": "Advanced",
    "estimatedHours": 50,
    "problemStatement": "Understanding current cyberattack techniques is crucial for defense. A honeypota system designed to be an attractive but monitored targetprovides a safe way to observe attacker behavior in the wild.",
    "solution": "Deploy an open-source honeypot like Cowrie (for SSH/Telnet) or Dionaea (for various protocols) on a cloud VPS. Configure it to log all interactions. Let it run for a week to collect data. Then, use the ELK stack or Python scripts to ingest, parse, and analyze the logs. Create a report visualizing the types of attacks, common usernames/passwords used, and the geographic origins of attackers.",
    "skillsGained": ["Threat Intelligence", "Honeypot Deployment", "Log Analysis", "Network Security", "Data Visualization", "Intrusion Detection"],
    "techStack": [{"name": "Cowrie / Dionaea", "type": "Honeypot"}, {"name": "DigitalOcean / Linode", "type": "VPS"}, {"name": "ELK Stack (Optional)", "type": "Analytics"}, {"name": "Python", "type": "Scripting"}],
    "professionalPractices": {"operationalSecurity": {"title": "Operational Security", "description": "Learn to safely deploy and isolate a system intended to be attacked, ensuring it cannot be used to pivot into other systems."}, "indicatorOfCompromise": {"title": "Indicator of Compromise (IoC) Extraction", "description": "Practice identifying actionable intelligence (attacker IPs, malware hashes) from raw logs."}, "threatReporting": {"title": "Threat Reporting", "description": "Develop the skill of summarizing complex attack data into a clear, concise report for stakeholders."}},
    "milestones": [
      {"id": "cy_m1", "title": "Phase 1: Deployment", "goal": "Provision a cloud VPS and securely install and configure the honeypot software (e.g., Cowrie) using Docker.", "content": [ { "type": "paragraph", "value": "Use a low-cost VPS provider. It's critical to lock down firewall rules so that you can access the management interface, but the honeypot ports are exposed to the internet." } ] },
      {"id": "cy_m2", "title": "Phase 2: Data Collection", "goal": "Let the honeypot run and collect attack data over a period of 1-2 weeks. Monitor the logs to ensure it's working.", "content": [ { "type": "paragraph", "value": "You will start seeing automated login attempts within hours. Let the system collect a significant amount of data." } ] },
      {"id": "cy_m3", "title": "Phase 3: Log Analysis", "goal": "Ingest the collected JSON logs into a Python script using Pandas. Parse and aggregate the data to find key insights.", "content": [ { "type": "code", "language": "python", "value": "import pandas as pd\n\n# Load the Cowrie JSON logs\ndf = pd.read_json('path/to/cowrie.json', lines=True)\n\n# Top 10 usernames tried\nprint(df[df['eventid'] == 'cowrie.login.failed']['username'].value_counts().head(10))\n\n# Top 10 attacker IP addresses\nprint(df['src_ip'].value_counts().head(10))" } ] },
      {"id": "cy_m4", "title": "Phase 4: Reporting", "goal": "Create a comprehensive threat intelligence report visualizing attack origins on a world map, top credentials used, and common commands executed by successful attackers.", "content": [ { "type": "paragraph", "value": "Use a library like GeoPandas or Plotly to create a map visualization. The report should summarize your findings in a way that a non-technical stakeholder could understand." } ] }
    ]
  },
  {
    "id": 13,
    "title": "Real-Time Collaborative Code Editor",
    "tagline": "Build a web-based code editor where multiple users can write and edit code together in real-time, similar to VS Code Live Share.",
    "domain": "Full-Stack & Real-Time Applications",
    "difficulty": "Expert",
    "estimatedHours": 110,
    "problemStatement": "Real-time text collaboration is complex due to concurrency issues. A robust system is needed to synchronize text changes from multiple users without conflicts, using advanced data structures.",
    "solution": "Use React with a code editor library like Monaco (the engine behind VS Code). On the backend, use Node.js and WebSockets. The core of the project is implementing an Operational Transformation (OT) or a Conflict-free Replicated Data Type (CRDT) like Y.js to handle merging simultaneous edits from different users without data loss.",
    "skillsGained": ["Operational Transformation (OT)", "CRDTs (Y.js)", "WebSockets", "Real-time State Synchronization", "Concurrency Control", "Advanced Frontend"],
    "techStack": [{"name": "React", "type": "Library"}, {"name": "Node.js", "type": "Runtime"}, {"name": "WebSocket (Socket.io)", "type": "API"}, {"name": "Y.js", "type": "CRDT Library"}, {"name": "Monaco Editor", "type": "Component"}],
    "professionalPractices": {"conflictResolution": {"title": "Conflict-Free State Merging", "description": "Dive deep into the computer science behind collaborative apps by implementing or using advanced algorithms (OT/CRDTs)."}, "lowLatencyUpdates": {"title": "Low-Latency UI Updates", "description": "Learn techniques to efficiently apply remote changes to the editor without disrupting the local user's typing experience."}, "sessionManagement": {"title": "Room and Session Management", "description": "Implement the backend logic to handle multiple independent collaboration sessions or 'rooms'."}},
    "milestones": [
      {"id": "collab_m1", "title": "Phase 1: Editor Setup", "goal": "Integrate the Monaco editor into a React application for single-user editing.", "content": [ { "type": "paragraph", "value": "Get the editor component rendering and functioning correctly for one user before introducing any networking." } ] },
      {"id": "collab_m2", "title": "Phase 2: Basic WebSocket Sync", "goal": "Set up a WebSocket server to broadcast entire document changes, demonstrating basic (but flawed) synchronization.", "content": [ { "type": "paragraph", "value": "When one user types, send the entire document content to the server, which then broadcasts it to all other clients. This will demonstrate the problem of conflicting edits." } ] },
      {"id": "collab_m3", "title": "Phase 3: CRDT Integration", "goal": "Replace the naive sync with a CRDT library like Y.js. Both client and server will now sync document 'updates' or 'diffs', not the entire content.", "content": [ { "type": "paragraph", "value": "This is the core of the project. Y.js will handle the complex logic of merging concurrent edits in a mathematically consistent way." } ] },
      {"id": "collab_m4", "title": "Phase 4: Awareness and Cursors", "goal": "Implement a presence/awareness feature using the Y.js awareness protocol to show other users' cursor positions and selections in real-time.", "content": [ { "type": "paragraph", "value": "This feature makes the collaboration feel much more 'live' and is a key part of modern collaborative editors." } ] }
    ]
  },
  {
    "id": 14,
    "title": "Image Segmentation API with U-Net",
    "tagline": "Train and deploy a deep learning model to perform semantic segmentation, identifying and outlining objects in an image at the pixel level.",
    "domain": "AI/ML & Computer Vision",
    "difficulty": "Advanced",
    "estimatedHours": 90,
    "problemStatement": "Object detection places a bounding box around an object. Semantic segmentation is more precise, classifying every single pixel in an image. This is vital for medical imaging, autonomous driving, and satellite imagery analysis.",
    "solution": "Implement a U-Net, a type of convolutional neural network architecture, using PyTorch or TensorFlow. Train the model on a public segmentation dataset (e.g., the Carvana Image Masking Challenge on Kaggle). Once trained, wrap the model in a FastAPI server that accepts an image and returns a mask image showing the segmented objects.",
    "skillsGained": ["Deep Learning", "Semantic Segmentation", "U-Net Architecture", "PyTorch/TensorFlow", "Image Data Augmentation", "ML Model Serving", "Computer Vision"],
    "techStack": [{"name": "Python", "type": "Language"}, {"name": "PyTorch / TensorFlow", "type": "DL Framework"}, {"name": "OpenCV", "type": "CV Library"}, {"name": "FastAPI", "type": "API"}],
    "professionalPractices": {"pixelLevelClassification": {"title": "Pixel-Level Classification", "description": "Move beyond image classification and learn the complexities of producing pixel-perfect output masks."}, "encoderDecoderArchitecture": {"title": "Encoder-Decoder Architecture", "description": "Understand the U-Net's powerful design, which first downsamples to capture context and then upsamples to localize features precisely."}, "customTrainingLoops": {"title": "Custom Training Loops", "description": "Gain experience writing a full training pipeline, including data loading, model training, validation, and saving checkpoints."}},
    "milestones": [
      {"id": "seg_m1", "title": "Phase 1: Data Pipeline", "goal": "Create a custom dataset loader in PyTorch to handle images and their corresponding segmentation masks from the Carvana dataset on Kaggle.", "content": [ { "type": "paragraph", "value": "Data loading is a critical first step. Your loader must be able to read an image and its corresponding single-channel mask image." } ] },
      {"id": "seg_m2", "title": "Phase 2: Model Implementation", "goal": "Build the U-Net model architecture from scratch using deep learning framework layers (Conv2d, ReLU, MaxPool2d, ConvTranspose2d).", "content": [ { "type": "paragraph", "value": "This involves creating the 'encoder' (downsampling path) and 'decoder' (upsampling path) with skip connections between them." } ] },
      {"id": "seg_m3", "title": "Phase 3: Training", "goal": "Write and execute the training loop for the model. Use a suitable loss function for segmentation (like Dice Loss or Binary Cross-Entropy) and an optimizer (like Adam).", "content": [ { "type": "paragraph", "value": "Monitor the validation loss to check for overfitting and save the model with the best performance." } ] },
      {"id": "seg_m4", "title": "Phase 4: Deployment", "goal": "Wrap the trained model in a FastAPI endpoint that takes an image, preprocesses it, runs inference, and returns the predicted binary mask image.", "content": [ { "type": "paragraph", "value": "This makes your trained model usable by other applications via a simple API call." } ] }
    ]
  },
  {
    "id": 15,
    "title": "Browser-Based 2D Platformer Game",
    "tagline": "Develop a classic 2D platformer game using the Phaser.js game engine, complete with physics, animations, and collectibles.",
    "domain": "Game Development",
    "difficulty": "Intermediate",
    "estimatedHours": 75,
    "problemStatement": "Game development involves complex concepts like a game loop, physics, and sprite management. A framework is needed to manage this complexity for the web.",
    "solution": "Use Phaser.js within a Vite project. Create a game with a player character who can run and jump. Design a level using a tilemap created with Tiled. Implement physics for gravity and collisions. Add collectibles and a simple UI to display the score. Structure the game into distinct Phaser Scenes.",
    "skillsGained": ["Game Development", "Game Engine (Phaser.js)", "Game Loop & Scenes", "2D Physics", "Tilemap Level Design", "Asset Management"],
    "techStack": [{"name": "Phaser.js", "type": "Game Engine"}, {"name": "TypeScript", "type": "Language"}, {"name": "Tiled", "type": "Level Editor"}, {"name": "Vite", "type": "Build Tool"}],
    "professionalPractices": {"sceneManagement": {"title": "Scene-Based Game Architecture", "description": "Structure your game into modular 'Scenes' (Main Menu, Level 1), a fundamental pattern for organizing game logic."}, "entityComponentSystem": {"title": "Entity-Component Thinking", "description": "Understand creating game objects (Entities) by composing behaviors (Components)."}, "assetLifecycle": {"title": "Game Asset Lifecycle", "description": "Practice the full lifecycle of game assets: preloading, using, and cleaning up resources."}},
    "milestones": [
      {"id": "game_m1", "title": "Phase 1: Setup and Player", "goal": "Set up a Phaser project using a Vite template and implement a player sprite with arcade physics and keyboard controls.", "content": [ { "type": "paragraph", "value": "This phase brings the character to life. You'll load a spritesheet, create animations for 'left', 'right', and 'idle', and check for keyboard input in the scene's `update` loop." } ] },
      {"id": "game_m2", "title": "Phase 2: Level Design with Tilemaps", "goal": "Create a simple level in the Tiled map editor. Export it as JSON and load it into Phaser to create static collision platforms.", "content": [ { "type": "paragraph", "value": "Instead of placing platforms manually in code, a tilemap allows for visual level design. You will load the tileset image and the JSON map data to construct the level." } ] },
      {"id": "game_m3", "title": "Phase 3: Gameplay and Collectibles", "goal": "Add a group of collectible items (e.g., stars) to the level. Use a physics overlap check to detect when the player collects one and update a score variable.", "content": [ { "type": "code", "language": "javascript", "value": "// In MainGameScene.js\nconst stars = this.physics.add.group({ key: 'star', repeat: 11, setXY: { x: 12, y: 0, stepX: 70 } });\nthis.physics.add.overlap(this.player, stars, collectStar, null, this);\n\nfunction collectStar(player, star) {\n    star.disableBody(true, true);\n    // Increment score logic here\n}" } ] },
      {"id": "game_m4", "title": "Phase 4: UI and Polish", "goal": "Create a separate, parallel UI Scene to overlay the score and health on top of the game. Add sound effects for jumping and collecting items.", "content": [ { "type": "paragraph", "value": "Running the UI in a parallel scene is a professional practice that separates game logic from display logic. Use events to communicate between the game scene and the UI scene." } ] }
    ]
  },
  {
    "id": 16,
    "title": "Build a Custom Memory Allocator in C",
    "tagline": "Implement `malloc` and `free` from scratch to gain a deep understanding of low-level memory management.",
    "domain": "Systems Programming",
    "difficulty": "Expert",
    "estimatedHours": 60,
    "problemStatement": "The standard library's memory allocator is a black box. Understanding how it manages the heap, handles fragmentation, and tracks free blocks is a crucial skill for high-performance and embedded systems programming.",
    "solution": "In C, write your own versions of `malloc`, `free`, `calloc`, and `realloc`. You will request large blocks of memory from the OS using `sbrk()` and then manage this memory yourself. Implement a free list data structure (e.g., a linked list of free blocks) to keep track of available memory and use an allocation strategy like 'first-fit' or 'best-fit'.",
    "skillsGained": ["Memory Management", "Pointers", "Data Structures", "Systems Calls (sbrk)", "Low-Level Programming", "Debugging Memory"],
    "techStack": [{"name": "C", "type": "Language"}, {"name": "GDB", "type": "Debugger"}, {"name": "Valgrind", "type": "Memory Profiler"}],
    "professionalPractices": {"heapManagement": {"title": "Heap Management", "description": "Directly manage the program's heap, learning the challenges of allocating and deallocating variable-sized blocks."}, "fragmentation": {"title": "Handling Fragmentation", "description": "Understand and experience the problem of memory fragmentation and why strategies like block coalescing are necessary."}, "metadataManagement": {"title": "Memory Block Metadata", "description": "Learn to store metadata (like block size) alongside the memory blocks themselves without interfering with the user's data."}},
    "milestones": [
      {"id": "mem_m1", "title": "Phase 1: The Basic Allocator", "goal": "Implement a simple allocator that uses a pointer to the start of the free memory region. It can only allocate, not free.", "content": [ { "type": "paragraph", "value": "You'll use the `sbrk(0)` system call to find the current end of the data segment (the 'program break') and manage allocations from there." } ] },
      {"id": "mem_m2", "title": "Phase 2: The Free List", "goal": "Implement `free` and a linked list data structure to manage freed blocks of memory. Each free block will contain a header with its size and a pointer to the next free block.", "content": [ { "type": "paragraph", "value": "This is the core data structure. When `free` is called, you'll add the block to this list. When `malloc` is called, you'll search this list for a suitable block." } ] },
      {"id": "mem_m3", "title": "Phase 3: Allocation Strategy and Block Splitting", "goal": "Implement a 'first-fit' strategy to search the free list. If a found block is larger than needed, split it into two: one to return to the user and a smaller remainder block that goes back on the free list.", "content": [ { "type": "paragraph", "value": "Block splitting is essential for reducing internal fragmentation and using memory more efficiently." } ] },
      {"id": "mem_m4", "title": "Phase 4: Coalescing Blocks", "goal": "Enhance your `free` implementation to check if the block being freed is physically adjacent to other free blocks in memory. If so, merge them into a single, larger free block to combat external fragmentation.", "content": [ { "type": "paragraph", "value": "Coalescing is the opposite of splitting and is crucial for maintaining a healthy heap over time." } ] }
    ]
  },
  {
    "id": 17,
    "title": "Build a Kubernetes Operator",
    "tagline": "Extend Kubernetes with custom logic to automate the management of a complex, stateful application.",
    "domain": "DevOps & Cloud Native",
    "difficulty": "Expert",
    "estimatedHours": 100,
    "problemStatement": "Kubernetes is great for stateless apps, but managing stateful applications like databases often requires manual intervention. The Operator pattern allows you to encode this human operational knowledge into software that runs inside Kubernetes.",
    "solution": "Using the Go-based Kubebuilder or Operator SDK, develop a Kubernetes Operator for a simple database (e.g., a Redis primary/replica setup). Define a Custom Resource Definition (CRD) for your database cluster (e.g., `kind: RedisCluster`). The operator's control loop will watch for these custom resources and create/manage the necessary Kubernetes objects (Deployments, Services, ConfigMaps) to match the desired state.",
    "skillsGained": ["Kubernetes", "Go (Golang)", "Operator Pattern", "Custom Resource Definitions (CRDs)", "Reconciliation Loops", "Cloud Native Architecture"],
    "techStack": [{"name": "Kubernetes", "type": "Orchestrator"}, {"name": "Go", "type": "Language"}, {"name": "Kubebuilder / Operator SDK", "type": "Framework"}, {"name": "Docker", "type": "Containerization"}],
    "professionalPractices": {"declarativeApis": {"title": "Declarative APIs", "description": "Learn to think in terms of desired state vs. actual state, the core principle of Kubernetes."}, "controlLoops": {"title": "Control Loops (Reconciliation)", "description": "Master the concept of a control loop that constantly works to drive the current state of the world toward the desired state defined in a resource."}, "extendingKubernetes": {"title": "Extending Kubernetes", "description": "Gain a deep understanding of how to add new, custom functionality to the Kubernetes API."}},
    "milestones": [
      {"id": "op_m1", "title": "Phase 1: Project Scaffolding and CRD", "goal": "Use Kubebuilder to initialize a new operator project. Define the API for your `RedisCluster` custom resource, specifying fields like `size` and `version` in a Go struct.", "content": [ { "type": "paragraph", "value": "The framework generates a lot of boilerplate for you. Your main task here is to define the `Spec` (desired state) and `Status` (observed state) of your custom resource." } ] },
      {"id": "op_m2", "title": "Phase 2: Basic Controller Logic", "goal": "Implement the core reconciliation loop in Go. When a `RedisCluster` resource is created, your controller should create a corresponding Kubernetes Deployment.", "content": [ { "type": "paragraph", "value": "The `Reconcile` function is the heart of the operator. You'll write Go code to check if a Deployment exists. If not, you'll define a Deployment object in code and use the controller's client to create it in the cluster." } ] },
      {"id": "op_m3", "title": "Phase 3: Handling State and Updates", "goal": "Add logic to the reconciliation loop to handle updates. If a user changes the `size` field in the `RedisCluster` spec, your operator should scale the corresponding Deployment up or down.", "content": [ { "type": "paragraph", "value": "This moves beyond simple creation. Your code must fetch the current state of the Deployment, compare its replica count to the desired size in your CRD, and issue an update if they don't match." } ] },
      {"id": "op_m4", "title": "Phase 4: Deployment and Testing", "goal": "Build the operator's Docker image, deploy it to a local Kubernetes cluster (like Minikube or Kind), and test its behavior by creating, updating, and deleting `RedisCluster` resources using `kubectl`.", "content": [ { "type": "paragraph", "value": "This is the validation step. You will write a YAML file for your custom resource, apply it with `kubectl apply`, and then use `kubectl get deployments` to verify that your operator correctly created the underlying resources." } ] }
    ]
  },
  {
    "id": 18,
    "title": "A/B Testing Framework Analysis and Proposal",
    "tagline": "Design an A/B testing framework for a product, defining the statistical methods, event tracking, and decision-making process.",
    "domain": "Product Management & Data Science",
    "difficulty": "Advanced",
    "estimatedHours": 40,
    "problemStatement": "Product teams need to make data-driven decisions, but simply launching a feature doesn't prove its effectiveness. A structured A/B testing framework is required to scientifically measure the impact of a change on key business metrics.",
    "solution": "For a hypothetical e-commerce site, you will write a comprehensive document proposing an A/B testing framework. This includes: defining the architecture for experiment configuration and user bucketing; writing a spec for the necessary analytics events; detailing the statistical analysis (e.g., t-tests, p-values, confidence intervals) to be used; and creating a standardized template for reporting experiment results and making a launch/no-launch decision.",
    "skillsGained": ["A/B Testing", "Experiment Design", "Statistical Analysis", "Product Analytics", "Data-Driven Decision Making", "Technical Writing"],
    "techStack": [{"name": "Confluence / Notion", "type": "Documentation"}, {"name": "Python (for stats)", "type": "Analysis"}, {"name": "Amplitude / Mixpanel (concepts)", "type": "Analytics"}],
    "professionalPractices": {"statisticalRigor": {"title": "Statistical Rigor", "description": "Learn the importance of concepts like statistical significance, power, and sample size in making valid conclusions from experiment data."}, "productInstrumentation": {"title": "Product Instrumentation", "description": "Understand that good experiments depend on good data, which requires defining and implementing a clear event tracking plan."}, "decisionFramework": {"title": "Decision Framework", "description": "Create a clear, repeatable process for how the company decides whether to ship, iterate on, or discard a feature based on A/B test results."}},
    "milestones": [
      {"id": "ab_m1", "title": "Phase 1: Framework Design Document", "goal": "Write a document detailing the technical and product requirements for a robust A/B testing system, including user bucketing logic and experiment configuration.", "content": [ { "type": "paragraph", "value": "This document is the blueprint. It should specify how an experiment is defined (control/variant groups, traffic allocation) and how users are consistently assigned to a group." } ] },
      {"id": "ab_m2", "title": "Phase 2: Statistical Plan and Calculator", "goal": "Detail the statistical tests to be used (e.g., two-sample t-test for conversion rate) and create a sample size calculator in a spreadsheet to determine how long an experiment needs to run.", "content": [ { "type": "paragraph", "value": "This ensures experiments are statistically sound. Your calculator will take inputs like baseline conversion rate, minimum detectable effect, and statistical power." } ] },
      {"id": "ab_m3", "title": "Phase 3: Case Study with Synthetic Data", "goal": "Run a hypothetical experiment analysis (e.g., 'Does a green vs. blue buy button increase conversion?'). Generate synthetic data in Python and perform the statistical analysis.", "content": [ { "type": "code", "language": "python", "value": "from statsmodels.stats.proportion import proportions_ztest\n\n# Sample data\ncontrol_conversions = 50\ncontrol_users = 1000\nvariant_conversions = 70\nvariant_users = 1000\n\nstat, p_value = proportions_ztest([control_conversions, variant_conversions], [control_users, variant_users])\nprint(f'P-value: {p_value}')" } ] },
      {"id": "ab_m4", "title": "Phase 4: Reporting Template", "goal": "Create a standardized, one-page template for presenting experiment results to stakeholders. It should include the hypothesis, key results, statistical summary, and a clear 'Ship It' or 'Don't Ship It' recommendation.", "content": [ { "type": "paragraph", "value": "Clear communication of results is as important as the analysis itself. This template ensures consistency and focuses on the final business decision." } ] }
    ]
  },
  {
    "id": 19,
    "title": "Build a Recommendation Engine From Scratch",
    "tagline": "Implement a collaborative filtering recommendation system to suggest items to users based on past behavior.",
    "domain": "Data Science & AI/ML",
    "difficulty": "Advanced",
    "estimatedHours": 70,
    "problemStatement": "Personalization is key to user engagement in e-commerce and content platforms. A recommendation engine is needed to predict which items a user will like, based on the preferences of similar users.",
    "solution": "Using Python and the MovieLens dataset, implement a user-based collaborative filtering algorithm. This involves: creating a user-item interaction matrix; calculating similarity between users (e.g., using cosine similarity); and generating recommendations for a target user by finding items liked by the most similar users. Compare this to an item-based approach.",
    "skillsGained": ["Recommendation Systems", "Collaborative Filtering", "Similarity Metrics", "Matrix Factorization (Optional)", "Data Science", "Python (NumPy, Pandas)"],
    "techStack": [{"name": "Python", "type": "Language"}, {"name": "Pandas", "type": "Data Manipulation"}, {"name": "NumPy", "type": "Numerical"}, {"name": "Scikit-learn", "type": "ML"}],
    "professionalPractices": {"coldStartProblem": {"title": "The Cold Start Problem", "description": "Understand and discuss the challenge of providing recommendations for new users or new items with no interaction data."}, "scalability": {"title": "Scalability Challenges", "description": "Analyze the computational complexity of your approach and research how techniques like matrix factorization (e.g., SVD) help solve scalability issues."}, "evaluationMetrics": {"title": "Offline Evaluation Metrics", "description": "Learn to evaluate your recommender system using offline metrics like precision and recall at k."}},
    "milestones": [
      {"id": "rec_m1", "title": "Phase 1: Data Exploration and Preparation", "goal": "Load and explore the MovieLens dataset (available from GroupLens). Create a sparse user-item matrix from the ratings data.", "content": [ { "type": "paragraph", "value": "The data needs to be transformed into a matrix where rows are users, columns are movies, and values are ratings." }, { "type": "code", "language": "python", "value": "import pandas as pd\n\n# Assuming you have ratings.csv and movies.csv\nratings = pd.read_csv('ratings.csv')\nuser_item_matrix = ratings.pivot_table(index='userId', columns='movieId', values='rating')\nprint(user_item_matrix.head())" } ] },
      {"id": "rec_m2", "title": "Phase 2: User-Based Collaborative Filtering", "goal": "Implement the algorithm to find similar users based on their rating patterns and generate recommendations.", "content": [ { "type": "paragraph", "value": "This involves calculating the cosine similarity between all pairs of users and, for a target user, selecting the top N similar users to source recommendations from." }, { "type": "code", "language": "python", "value": "from sklearn.metrics.pairwise import cosine_similarity\n\n# Fill NaNs for similarity calculation\nuser_similarity = cosine_similarity(user_item_matrix.fillna(0))" } ] },
      {"id": "rec_m3", "title": "Phase 3: Item-Based Collaborative Filtering", "goal": "Implement an item-based approach by transposing the user-item matrix and finding similar items. Compare its results and performance to the user-based method.", "content": [ { "type": "paragraph", "value": "Item-based filtering is often more scalable and stable than user-based. This phase demonstrates your understanding of different approaches and their trade-offs." } ] },
      {"id": "rec_m4", "title": "Phase 4: Evaluation", "goal": "Split the data into a training and test set to evaluate the accuracy of your recommendations using a metric like Root Mean Squared Error (RMSE).", "content": [ { "type": "paragraph", "value": "You'll need to predict the ratings for the user-item pairs in the test set and compare them to the actual known ratings to quantify your model's performance." } ] }
    ]
  },
  {
    "id": 20,
    "title": "Build a Linux Shell in C",
    "tagline": "Create your own command-line interpreter that can parse commands, handle arguments, and execute programs.",
    "domain": "Systems Programming",
    "difficulty": "Intermediate",
    "estimatedHours": 40,
    "problemStatement": "The shell is the fundamental interface for interacting with a Unix-like operating system. Building one provides a deep understanding of process management, system calls, and I/O redirection.",
    "solution": "In C, write a program that presents a prompt, reads a line of input, parses the line into a command and its arguments, and then uses `fork()` and `execvp()` to create a child process that executes the command. Extend the shell to handle built-in commands (like `cd` and `exit`), I/O redirection (`>` and `<`), and pipes (`|`).",
    "skillsGained": ["Process Management (fork, exec)", "System Calls", "I/O Redirection", "Pipes", "C Programming", "Parsing User Input"],
    "techStack": [{"name": "C", "type": "Language"}, {"name": "GCC", "type": "Compiler"}, {"name": "Linux", "type": "OS"}],
    "professionalPractices": {"processLifecycle": {"title": "Process Lifecycle", "description": "Gain a concrete understanding of how new processes are created, executed, and waited upon by a parent process."}, "fileDescriptors": {"title": "File Descriptors", "description": "Directly manipulate file descriptors to implement powerful features like I/O redirection and pipes."}, "errorHandling": {"title": "Robust Error Handling", "description": "Practice checking the return values of every system call, a critical habit for reliable systems programming."}},
    "milestones": [
      {"id": "shell_m1", "title": "Phase 1: The REPL and Parsing", "goal": "Create the basic Read-Eval-Print Loop. Implement a function to read a line of user input and parse it into an array of tokens (arguments).", "content": [ { "type": "paragraph", "value": "You'll use `getline()` to read input and `strtok()` to split the line into command and arguments." } ] },
      {"id": "shell_m2", "title": "Phase 2: Command Execution", "goal": "Use the `fork()` system call to create a child process and `execvp()` within the child to execute the parsed command.", "content": [ { "type": "callout", "style": "info", "value": "The parent process should use `waitpid()` to wait for the child process to complete before printing the next prompt." } ] },
      {"id": "shell_m3", "title": "Phase 3: I/O Redirection", "goal": "Add support for redirecting standard input (`<`) and standard output (`>`). This involves parsing for these symbols and using the `dup2()` system call to manipulate file descriptors before calling `execvp()`.", "content": [ { "type": "paragraph", "value": "For output redirection, you'll open a file and use `dup2()` to make the standard output file descriptor (1) point to your opened file." } ] },
      {"id": "shell_m4", "title": "Phase 4: Pipes", "goal": "Implement piping (`|`) to connect the stdout of one command to the stdin of another. This requires using the `pipe()` system call to create a pipe, forking two children, and using `dup2()` in each child to wire them up to the pipe.", "content": [ { "type": "paragraph", "value": "This is the most complex phase and demonstrates a deep understanding of process and file descriptor management." } ] }
    ]
  },
  {
    "id": 21,
    "title": "Full-Stack E-Commerce Platform",
    "tagline": "Build a complete e-commerce website with product listings, a shopping cart, user authentication, and payment processing with Stripe.",
    "domain": "Full-Stack",
    "difficulty": "Advanced",
    "estimatedHours": 120,
    "problemStatement": "Building an online store requires a robust backend for products and orders, a secure payment system, a user-friendly frontend, and a persistent shopping cart.",
    "solution": "Develop a Next.js application using Prisma as an ORM to a PostgreSQL database. Implement user authentication with NextAuth.js. Build a shopping cart using client-side state management (e.g., Zustand). Integrate Stripe Checkout for secure payment processing.",
    "skillsGained": ["Full-Stack Development", "Database Modeling", "ORM (Prisma)", "Authentication", "Payment Gateway Integration (Stripe)", "State Management"],
    "techStack": [{"name": "Next.js", "type": "Framework"}, {"name": "PostgreSQL", "type": "Database"}, {"name": "Prisma", "type": "ORM"}, {"name": "Stripe", "type": "Payments"}, {"name": "NextAuth.js", "type": "Auth"}],
    "professionalPractices": {"relationalDataModeling": {"title": "Relational Data Modeling", "description": "Design a relational schema with clear relationships between Users, Products, and Orders."}, "securePaymentHandling": {"title": "Secure Payment Handling", "description": "Learn to never handle raw credit card data, instead orchestrating a secure checkout session with a provider like Stripe."}, "sessionManagement": {"title": "Authentication and Session Management", "description": "Implement robust user login, registration, and session management using a battle-tested library."}},
    "milestones": [
      {"id": "ecom_m1", "title": "Phase 1: Setup and Product Display", "goal": "Set up the Next.js project, define the database schema with Prisma, seed it with sample products, and build pages to display them.", "content": [ { "type": "paragraph", "value": "The foundation is a well-defined data model. Use `prisma/schema.prisma` to define your Product and User models, then run `npx prisma migrate dev` to create the tables." } ] },
      {"id": "ecom_m2", "title": "Phase 2: Shopping Cart", "goal": "Implement a client-side shopping cart using a global state manager like Zustand or Redux Toolkit. Allow users to add, remove, and update item quantities.", "content": [ { "type": "callout", "style": "info", "value": "To make the cart persist across browser sessions, use a middleware to sync the cart state to `localStorage`." } ] },
      {"id": "ecom_m3", "title": "Phase 3: Authentication and Checkout", "goal": "Integrate NextAuth.js for user login and signup. Create a checkout flow that generates a Stripe Checkout session via a backend API route.", "content": [ { "type": "code", "language": "javascript", "value": "// pages/api/checkout_sessions.ts (conceptual)\nconst session = await stripe.checkout.sessions.create({\n  payment_method_types: ['card'],\n  line_items,\n  mode: 'payment',\n  success_url: `${req.headers.origin}/result?session_id={CHECKOUT_SESSION_ID}`,\n  cancel_url: `${req.headers.origin}/cart`,\n});" } ] },
      {"id": "ecom_m4", "title": "Phase 4: Order Fulfillment via Webhooks", "goal": "Use Stripe webhooks to listen for successful payments. When a `checkout.session.completed` event is received, create Order and OrderItem records in your database.", "content": [ { "type": "paragraph", "value": "This closes the loop reliably. You'll create a dedicated webhook API route that receives events from Stripe, verifies their authenticity, and then uses Prisma to save the order details." } ] }
    ]
  },
  {
    "id": 22,
    "title": "Change Data Capture (CDC) Pipeline with Debezium",
    "tagline": "Build a real-time pipeline that captures database changes as an event stream and syncs them to a data warehouse.",
    "domain": "Data Engineering",
    "difficulty": "Expert",
    "estimatedHours": 90,
    "problemStatement": "Keeping downstream systems like data warehouses in sync with a production database is challenging. Polling is inefficient. A better solution is needed to capture every change as it happens.",
    "solution": "Use Debezium to monitor a PostgreSQL database's transaction log (WAL). Debezium will capture changes and stream them as events to a Kafka topic. A consumer application will then read these events and apply the changes to a target system, such as a BigQuery table or a console output.",
    "skillsGained": ["Change Data Capture (CDC)", "Debezium", "Apache Kafka", "Database Internals (Transaction Logs)", "Event-Driven Architecture", "Data Synchronization"],
    "techStack": [{"name": "Debezium", "type": "CDC Platform"}, {"name": "Kafka", "type": "Stream Platform"}, {"name": "PostgreSQL", "type": "Database"}, {"name": "Docker", "type": "Containerization"}, {"name": "Kafka Connect", "type": "Framework"}],
    "professionalPractices": {"logBasedCdc": {"title": "Log-Based CDC", "description": "Understand the powerful and non-intrusive method of capturing data changes by reading the database's internal transaction log."}, "eventSourcingPattern": {"title": "Event Sourcing Pattern", "description": "Learn how to represent the state of a system as a sequence of events, fundamental to many modern distributed systems."}, "exactlyOnceSemantics": {"title": "Delivery Semantics", "description": "Grapple with the challenges of data delivery in distributed systems, understanding concepts like 'at-least-once' and 'exactly-once' processing."}},
    "milestones": [
      {"id": "cdc_m1", "title": "Phase 1: Infrastructure", "goal": "Set up PostgreSQL, Kafka, Zookeeper, and Kafka Connect (with Debezium) using a single Docker Compose file.", "content": [ { "type": "paragraph", "value": "You will need to configure PostgreSQL for logical replication (`wal_level = logical`) for Debezium to work." } ] },
      {"id": "cdc_m2", "title": "Phase 2: Connector Configuration", "goal": "Use a REST API call to the Kafka Connect service to configure and deploy the Debezium PostgreSQL connector to monitor a specific table.", "content": [ { "type": "paragraph", "value": "You'll post a JSON configuration object that tells Debezium which database and tables to watch." } ] },
      {"id": "cdc_m3", "title": "Phase 3: Data Streaming", "goal": "Connect to the PostgreSQL database and make changes (INSERT, UPDATE, DELETE). Observe the detailed change-event JSON objects appearing in the corresponding Kafka topic using a command-line consumer.", "content": [ { "type": "paragraph", "value": "This step validates that the entire capture pipeline is working correctly." } ] },
      {"id": "cdc_m4", "title": "Phase 4: Consumer Application", "goal": "Write a simple consumer application (e.g., in Python) that reads the change events and prints a human-readable summary of the changes, demonstrating how a downstream system would process the data.", "content": [ { "type": "paragraph", "value": "Your consumer will need to parse the complex Debezium event format, which includes 'before' and 'after' states for the data row." } ] }
    ]
  },
  {
    "id": 23,
    "title": "Build a DNS Server from Scratch in Rust",
    "tagline": "Implement a basic DNS resolver that can parse DNS query packets and fetch records from authoritative nameservers.",
    "domain": "Networking & Systems Programming",
    "difficulty": "Expert",
    "estimatedHours": 80,
    "problemStatement": "DNS is a foundational protocol of the internet, yet its inner workings are often taken for granted. Building a simple DNS server provides a deep understanding of network protocols, UDP socket programming, and binary data parsing.",
    "solution": "Using Rust, build a program that listens for DNS queries on UDP port 53. Implement data structures to parse and construct DNS packets according to RFC 1035. Your server will receive a query, parse it, forward it to a public resolver like 8.8.8.8, receive the response, and then forward that response back to the original client. The advanced goal is to implement recursive resolution yourself.",
    "skillsGained": ["Network Programming", "UDP Sockets", "Binary Protocol Parsing", "Rust", "Concurrency", "DNS Protocol (RFC 1035)"],
    "techStack": [{"name": "Rust", "type": "Language"}, {"name": "Tokio (for async)", "type": "Library"}, {"name": "Wireshark", "type": "Debugging Tool"}],
    "professionalPractices": {"rfcImplementation": {"title": "RFC Implementation", "description": "Gain experience reading and implementing a technical standard (RFC), a core skill for low-level engineering."}, "byteLevelManipulation": {"title": "Byte-Level Manipulation", "description": "Work directly with byte streams, learning how to parse and construct binary data with bit-level precision."}, "protocolRecursion": {"title": "Protocol Recursion/Iteration", "description": "Understand the recursive nature of DNS resolution, where your server must query a series of other servers to find the final answer."}},
    "milestones": [
      {"id": "dns_m1", "title": "Phase 1: Packet Parsing and Building", "goal": "Implement data structures and parsing/building logic in Rust to deconstruct and construct raw DNS query and response packets according to the RFC spec.", "content": [ { "type": "paragraph", "value": "This is the hardest part. You will need to handle bit-level flags in the header and the variable-length format of domain names." } ] },
      {"id": "dns_m2", "title": "Phase 2: UDP Server", "goal": "Create a UDP server using Tokio that can listen for incoming queries on port 53 and parse them using your logic from Phase 1.", "content": [ { "type": "paragraph", "value": "You can test this using `dig @127.0.0.1 google.com` and use Wireshark to inspect the packets." } ] },
      {"id": "dns_m3", "title": "Phase 3: Forwarding Resolver", "goal": "Implement the logic to forward the parsed query to a known public DNS resolver (like 8.8.8.8), receive the response, and forward it back to the original client.", "content": [ { "type": "paragraph", "value": "This creates a working, albeit simple, DNS server and validates your packet building logic." } ] },
      {"id": "dns_m4", "title": "Phase 4: Recursive Resolution (Advanced)", "goal": "Extend the server to perform its own recursive lookups. Start by querying a root server, then follow the chain of NS records returned until you reach the authoritative nameserver for the domain.", "content": [ { "type": "paragraph", "value": "This demonstrates a full understanding of the DNS resolution process." } ] }
    ]
  },
  {
    "id": 24,
    "title": "Build a WebAssembly-Powered Image Editor",
    "tagline": "Create a high-performance, in-browser image editing tool by compiling C++ or Rust code to WebAssembly.",
    "domain": "Frontend & WebAssembly",
    "difficulty": "Advanced",
    "estimatedHours": 60,
    "problemStatement": "Complex, computationally intensive tasks like image processing can be slow in JavaScript. WebAssembly (Wasm) allows developers to run code written in languages like C++ or Rust in the browser at near-native speeds.",
    "solution": "Write image processing functions (e.g., grayscale, Sobel edge detection) in Rust. Compile this Rust code to a WebAssembly module using `wasm-pack`. Build a React or Svelte frontend that allows a user to upload an image. The JavaScript code will then call the exported Wasm functions to apply filters to the image data on an HTML5 canvas.",
    "skillsGained": ["WebAssembly (Wasm)", "Rust / C++", "JavaScript Interoperability", "High-Performance Frontend", "Image Processing", "HTML5 Canvas"],
    "techStack": [{"name": "Rust", "type": "Language"}, {"name": "WebAssembly", "type": "Target"}, {"name": "wasm-pack", "type": "Tooling"}, {"name": "React / Svelte", "type": "Framework"}, {"name": "Vite", "type": "Build Tool"}],
    "professionalPractices": {"bridgingJsAndWasm": {"title": "Bridging JS and Wasm", "description": "Learn the patterns and tooling for passing data (especially large data like image buffers) efficiently between the JavaScript and WebAssembly runtimes."}, "performanceOptimization": {"title": "Frontend Performance Optimization", "description": "Identify CPU-bound bottlenecks in a web application and learn how to offload them to a more performant language via Wasm."}, "toolchainMastery": {"title": "Wasm Toolchain Mastery", "description": "Gain experience with the modern toolchain required to compile, package, and integrate Wasm modules into a web application."}},
    "milestones": [
      {"id": "wasm_m1", "title": "Phase 1: Rust Logic", "goal": "Write the core image processing functions in Rust, operating on a raw buffer of pixel data. Use the `wasm-bindgen` crate to expose these functions to JavaScript.", "content": [ { "type": "code", "language": "rust", "value": "use wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn grayscale(pixels: &mut [u8]) {\n    // ... logic to iterate through pixels and apply grayscale ...\n}" } ] },
      {"id": "wasm_m2", "title": "Phase 2: Compilation and Packaging", "goal": "Compile the Rust code to a WebAssembly module and package it for npm using `wasm-pack`.", "content": [ { "type": "code", "language": "bash", "value": "wasm-pack build --target web" } ] },
      {"id": "wasm_m3", "title": "Phase 3: Frontend Integration", "goal": "Build a JavaScript UI that loads the Wasm module. Create an interface with an image upload and buttons for each filter.", "content": [ { "type": "paragraph", "value": "Your frontend will `import` the functions from the generated package just like a regular JavaScript module." } ] },
      {"id": "wasm_m4", "title": "Phase 4: Canvas Rendering", "goal": "Implement the logic to draw the uploaded image to an HTML5 canvas, get its pixel data using `getImageData`, pass the data buffer to a Wasm function, and render the processed data back to the canvas using `putImageData`.", "content": [ { "type": "paragraph", "value": "This is the core interactive loop of the application." } ] }
    ]
  },
  {
    "id": 25,
    "title": "Design a Comprehensive Design System",
    "tagline": "Create a complete, documented design system from scratch to ensure brand consistency and development efficiency for a suite of products.",
    "domain": "UX/UI Design",
    "difficulty": "Advanced",
    "estimatedHours": 80,
    "problemStatement": "As product teams grow, inconsistencies in UI and UX appear, leading to a fragmented user experience and duplicated effort. A centralized design system is needed to provide a single source of truth.",
    "solution": "For a hypothetical company, create a full design system in Figma. This includes: defining foundational elements (color, typography, grid); building a library of reusable components (buttons, forms, modals) with variants; and writing clear usage guidelines. The final deliverable is a published Figma library and a documentation site (e.g., using Storybook or Zeroheight).",
    "skillsGained": ["Design Systems", "Component-Based Design", "UI/UX Design", "Documentation", "Figma Variants & Auto Layout", "Brand Identity"],
    "techStack": [{"name": "Figma", "type": "Design Tool"}, {"name": "Storybook / Zeroheight", "type": "Documentation"}, {"name": "Notion", "type": "Writing"}],
    "professionalPractices": {"atomicDesign": {"title": "Atomic Design Principles", "description": "Structure your system using the atomic design methodology, building complex components from simpler, reusable elements."}, "singleSourceOfTruth": {"title": "Single Source of Truth", "description": "Understand the value of creating a centralized system that both designers and developers use, reducing ambiguity."}, "documentationAndGovernance": {"title": "Documentation and Governance", "description": "Practice writing clear guidelines on when and how to use each component, a critical part of maintaining a design system."}},
    "milestones": [
      {"id": "ds_m1", "title": "Phase 1: Foundations (Design Tokens)", "goal": "Define the core design tokens: a semantic color palette (primary, secondary, error), a typographic scale, spacing units, and an iconography set.", "content": [ { "type": "paragraph", "value": "These are the foundational variables of your system. Define them as styles in Figma for easy reuse." } ] },
      {"id": "ds_m2", "title": "Phase 2: Component Library", "goal": "Build a comprehensive library of reusable UI components in Figma. Use variants and auto layout extensively to create flexible and scalable components like buttons, input fields, and cards.", "content": [ { "type": "paragraph", "value": "For example, a button component should have variants for different states (default, hover, disabled), sizes, and types (primary, secondary)." } ] },
      {"id": "ds_m3", "title": "Phase 3: Documentation", "goal": "For each major component, write clear usage guidelines. Document its purpose, anatomy, and do's and don'ts.", "content": [ { "type": "paragraph", "value": "Good documentation is what makes a design system usable. This can be done directly in Figma or in a tool like Notion." } ] },
      {"id": "ds_m4", "title": "Phase 4: Publishing and Hand-off", "goal": "Publish the Figma library so other designers can use it. Create a documentation site using a tool like Zeroheight that pulls directly from your Figma file, creating a public-facing resource for developers.", "content": [ { "type": "paragraph", "value": "This final step makes the design system an official, shared resource for the entire team." } ] }
    ]
  },
  {
    "id": 26,
    "title": "Home Automation Hub with Raspberry Pi",
    "tagline": "Build a centralized, open-source home automation system that integrates various smart devices and can be controlled via a web interface.",
    "domain": "IoT & Embedded Systems",
    "difficulty": "Advanced",
    "estimatedHours": 90,
    "problemStatement": "Commercial smart home ecosystems are often cloud-reliant and lock users into a single brand. A local, open-source hub is needed to provide vendor-agnostic control and ensure privacy.",
    "solution": "Use a Raspberry Pi to run Home Assistant. You will physically integrate several devices, such as a Zigbee USB dongle to control smart bulbs and sensors, and write custom automations in YAML (e.g., 'turn on hallway light when motion is detected, but only at night'). You will also build a custom dashboard (Lovelace UI) to control all devices from a web interface.",
    "skillsGained": ["IoT", "Home Automation", "Raspberry Pi", "Linux System Administration", "YAML", "Zigbee/Z-Wave Protocols", "Networking"],
    "techStack": [{"name": "Home Assistant", "type": "Software"}, {"name": "Raspberry Pi", "type": "Hardware"}, {"name": "Zigbee2MQTT", "type": "Bridge"}, {"name": "Docker", "type": "Containerization"}],
    "professionalPractices": {"localFirstControl": {"title": "Local-First Control", "description": "Understand the benefits and challenges of building a system that operates entirely on the local network, without reliance on cloud servers."}, "interoperability": {"title": "Device Interoperability", "description": "Gain experience integrating devices from different manufacturers using open standards like Zigbee and MQTT."}, "eventDrivenAutomation": {"title": "Event-Driven Automation", "description": "Learn to think in terms of triggers, conditions, and actions to create complex and robust automation rules."}},
    "milestones": [
      {"id": "ha_m1", "title": "Phase 1: Hub Setup", "goal": "Install Home Assistant OS on a Raspberry Pi by flashing the image to an SD card. Perform initial network configuration and user setup.", "content": [ { "type": "paragraph", "value": "Follow the official Home Assistant installation guide for the Raspberry Pi." } ] },
      {"id": "ha_m2", "title": "Phase 2: Device Integration", "goal": "Set up a Zigbee USB coordinator (like a Conbee II or Sonoff Dongle). Install the Zigbee2MQTT add-on and pair your first devices (e.g., an Aqara motion sensor and an IKEA smart bulb).", "content": [ { "type": "paragraph", "value": "This phase involves working with hardware and understanding mesh networking concepts." } ] },
      {"id": "ha_m3", "title": "Phase 3: Automation", "goal": "Write several useful automations using the built-in Automation Editor or by directly editing `automations.yaml`.", "content": [ { "type": "code", "language": "yaml", "value": "- alias: 'Turn on light on motion at night'\n  trigger:\n    - platform: state\n      entity_id: binary_sensor.motion_sensor_1\n      to: 'on'\n  condition:\n    - condition: sun\n      after: sunset\n  action:\n    - service: light.turn_on\n      entity_id: light.smart_bulb_1" } ] },
      {"id": "ha_m4", "title": "Phase 4: Dashboarding", "goal": "Design and build a custom Lovelace dashboard to provide an intuitive control interface. Group related devices into cards and create custom buttons to trigger scripts or scenes.", "content": [ { "type": "paragraph", "value": "A good dashboard makes the system usable for everyone in the household, not just the tech expert." } ] }
    ]
  },
  {
    "id": 27,
    "title": "Build a Distributed, Fault-Tolerant Key-Value Store",
    "tagline": "Implement a simplified version of a distributed database using the Raft consensus algorithm to ensure consistency and fault tolerance.",
    "domain": "Distributed Systems",
    "difficulty": "Expert",
    "estimatedHours": 150,
    "problemStatement": "A single-node database is a single point of failure. To build a reliable system, data must be replicated across multiple nodes, and a consensus algorithm is needed to ensure all nodes agree on the state, even if some nodes fail.",
    "solution": "In Go or Rust, build a key-value store that runs on multiple nodes. Implement the Raft consensus algorithm, which involves leader election, log replication, and safety mechanisms. The system should be able to tolerate the failure of a minority of its nodes and continue to accept reads and writes. You will build a simple client to interact with the cluster and demonstrate its fault-tolerant properties.",
    "skillsGained": ["Distributed Systems", "Consensus Algorithms (Raft)", "Fault Tolerance", "Replication", "RPC (gRPC)", "Concurrency"],
    "techStack": [{"name": "Go / Rust", "type": "Language"}, {"name": "gRPC", "type": "RPC Framework"}, {"name": "Protocol Buffers", "type": "Serialization"}],
    "professionalPractices": {"consensusAsAService": {"title": "Consensus as a Service", "description": "Understand how a consensus algorithm like Raft can be used as a building block to create a replicated state machine, a foundational concept for many distributed databases."}, "leaderElection": {"title": "Leader Election Dynamics", "description": "Implement and debug the process of leader election in a distributed system, including handling timeouts and split votes."}, "failureHandling": {"title": "Systematic Failure Handling", "description": "Design a system that is resilient to network partitions and node crashes, a hallmark of robust distributed systems."}},
    "milestones": [
      {"id": "raft_m1", "title": "Phase 1: Leader Election", "goal": "Implement the Raft leader election mechanism. Nodes will start as followers, become candidates after a timeout, and request votes from peers. A node that receives a majority of votes becomes the leader and sends periodic heartbeats.", "content": [ { "type": "paragraph", "value": "This is the first part of the Raft protocol. You'll need to manage state (follower, candidate, leader) and timers for each node." } ] },
      {"id": "raft_m2", "title": "Phase 2: Log Replication", "goal": "Implement the log replication process. A client sends a command to the leader. The leader appends it to its own log and sends AppendEntries RPCs to its followers. Once a majority of nodes have replicated the entry, the leader commits it and applies it to its state machine.", "content": [ { "type": "paragraph", "value": "This ensures that all committed commands are durably stored on a majority of servers." } ] },
      {"id": "raft_m3", "title": "Phase 3: State Machine and Client Interaction", "goal": "Integrate a simple key-value state machine. When a log entry is committed, it is applied to this state machine. Build a simple gRPC server on the leader to handle client Set/Get requests.", "content": [ { "type": "paragraph", "value": "This connects the consensus logic to an actual, usable application." } ] },
      {"id": "raft_m4", "title": "Phase 4: Testing Fault Tolerance", "goal": "Write tests or a script to demonstrate that the cluster can survive a node failure. Kill the leader process; the remaining nodes should time out, start a new election, and elect a new leader, allowing the cluster to continue serving requests.", "content": [ { "type": "paragraph", "value": "This is the ultimate test of your implementation and demonstrates the core value of a consensus algorithm." } ] }
    ]
  },
  {
    "id": 28,
    "title": "Static Code Analysis Tool for Security Vulnerabilities",
    "tagline": "Build a tool that analyzes source code to find common security flaws like SQL injection or hardcoded secrets.",
    "domain": "Cybersecurity & Software Engineering",
    "difficulty": "Advanced",
    "estimatedHours": 70,
    "problemStatement": "Security vulnerabilities are often introduced unknowingly. Manually reviewing all code is impractical. A Static Application Security Testing (SAST) tool is needed to automatically scan code and flag potential issues.",
    "solution": "In Python, build a command-line tool that scans a directory of code. Implement checks for specific vulnerability patterns using regular expressions and by parsing the code into an Abstract Syntax Tree (AST). The tool will detect issues like hardcoded API keys, use of dangerous functions (e.g., `eval`), and potential SQL injection vulnerabilities. The results will be printed in a clear, actionable report.",
    "skillsGained": ["Static Analysis (SAST)", "Abstract Syntax Tree (AST)", "Secure Coding Practices", "Regular Expressions", "Python Scripting", "Tool Development"],
    "techStack": [{"name": "Python", "type": "Language"}, {"name": "ast (Python library)", "type": "Parsing"}, {"name": "regex", "type": "Pattern Matching"}],
    "professionalPractices": {"astTraversal": {"title": "AST Traversal", "description": "Go beyond simple text matching and learn to analyze the semantic structure of code by traversing its AST."}, "vulnerabilityPatterns": {"title": "Vulnerability Pattern Recognition", "description": "Learn to identify the code-level signatures of common security vulnerabilities."}, "lowFalsePositives": {"title": "Reducing False Positives", "description": "Understand the challenge of building a security tool that is accurate and doesn't overwhelm users with false alarms."}},
    "milestones": [
      {"id": "sast_m1", "title": "Phase 1: Regex-Based Checks for Secrets", "goal": "Implement simple checks using regular expressions to find patterns that look like hardcoded secrets (e.g., `API_KEY = \"...\"`).", "content": [ { "type": "paragraph", "value": "This is the simplest form of static analysis. It's fast but can have high false positives. You'll learn about entropy-based checks as well." } ] },
      {"id": "sast_m2", "title": "Phase 2: AST Parsing and Dangerous Function Calls", "goal": "Integrate Python's `ast` module to parse source code into a traversable tree structure. Write a visitor class that walks the AST and flags calls to dangerous functions like `exec` or `eval`.", "content": [ { "type": "code", "language": "python", "value": "import ast\n\nclass DangerousCallVisitor(ast.NodeVisitor):\n    def visit_Call(self, node):\n        if isinstance(node.func, ast.Name) and node.func.id in ['eval', 'exec']:\n            print(f'Dangerous call to {node.func.id} on line {node.lineno}')\n        self.generic_visit(node)" } ] },
      {"id": "sast_m3", "title": "Phase 3: Taint Analysis for SQL Injection", "goal": "Implement a basic taint analysis rule. Traverse the AST to find cases where user-controlled input (e.g., from a web request) is used to construct a SQL query string without sanitization.", "content": [ { "type": "paragraph", "value": "This is a more advanced SAST technique. You'll track a variable from its source (tainted) to a sink (a dangerous function like a database query) to find vulnerabilities." } ] },
      {"id": "sast_m4", "title": "Phase 4: Reporting and CLI", "goal": "Develop a clear reporting format (e.g., JSON or text) that shows the vulnerability type, file, and line number for each finding. Wrap the tool in a user-friendly command-line interface using a library like `argparse`.", "content": [ { "type": "paragraph", "value": "A good tool needs a good user interface. The CLI should allow users to specify the directory to scan and the desired output format." } ] }
    ]
  },
  {
    "id": 29,
    "title": "Build a SQL Query Engine",
    "tagline": "Create a simplified query engine that can parse SQL SELECT statements, read data from CSV files, and execute basic filtering and joins.",
    "domain": "Databases & Backend",
    "difficulty": "Expert",
    "estimatedHours": 130,
    "problemStatement": "SQL is the standard language for data, but the process of how a declarative SQL query is turned into an imperative execution plan is complex. Building a simple query engine demystifies query planning, execution, and optimization.",
    "solution": "In a language like Java or Rust, build a multi-stage query engine. It will include: a SQL parser (using a library or writing your own) to create a logical plan; a planner that converts the logical plan into a physical execution plan (a tree of operators like 'Scan', 'Filter', 'Join'); and an execution engine that iterates through the plan to produce results from data stored in CSV files.",
    "skillsGained": ["Database Internals", "SQL Parsing", "Query Planning & Optimization", "Execution Engines", "Iterator Model", "Data Structures"],
    "techStack": [{"name": "Java/Rust", "type": "Language"}, {"name": "JSqlParser (Java)", "type": "Parsing"}, {"name": "Apache Arrow (Optional)", "type": "Data Format"}],
    "professionalPractices": {"declarativeToImperative": {"title": "Declarative to Imperative Translation", "description": "Understand the core task of a database: translating a declarative 'what' (SQL) into an imperative 'how' (an execution plan)."}, "volcanoIteratorModel": {"title": "Volcano/Iterator Model", "description": "Implement the standard database execution model where each operator in the plan has a `next()` method that pulls a tuple from its children."}, "queryOptimization": {"title": "Query Optimization Principles", "description": "Learn basic optimization rules, such as 'predicate pushdown,' where you apply filters as early as possible in the plan."}},
    "milestones": [
      {"id": "sql_m1", "title": "Phase 1: SQL Parser and Logical Plan", "goal": "Use a parser library to parse a simple `SELECT a, b FROM table WHERE c > 10` statement into a structured tree of logical nodes (e.g., Projection, Selection, Scan).", "content": [ { "type": "paragraph", "value": "This separates the SQL syntax from the semantics of the query." } ] },
      {"id": "sql_m2", "title": "Phase 2: Execution Engine - Scan and Filter", "goal": "Implement the 'Scan' and 'Filter' physical operators. The Scan operator reads rows from a CSV file. The Filter operator takes another operator as input and yields only the rows that match a predicate. Implement the Volcano iterator model (`open`, `next`, `close`).", "content": [ { "type": "paragraph", "value": "This allows you to execute simple `SELECT ... FROM ... WHERE` queries." } ] },
      {"id": "sql_m3", "title": "Phase 3: Joins", "goal": "Implement a nested loop join operator that takes two other operators as input and produces joined rows. This allows you to execute queries on two tables (CSVs).", "content": [ { "type": "paragraph", "value": "This is a foundational, albeit inefficient, join algorithm that is a great starting point." } ] },
      {"id": "sql_m4", "title": "Phase 4: Query Planner and Optimization", "goal": "Write a simple query planner that converts the logical plan from Phase 1 into a physical plan (a tree of your implemented operators). Implement a basic optimization rule like predicate pushdown.", "content": [ { "type": "paragraph", "value": "Predicate pushdown means moving `Filter` operators as close to the `Scan` operators as possible to reduce the number of rows processed by later stages like joins." } ] }
    ]
  },
  {
    "id": 30,
    "title": "Procedural 3D Voxel World Generation",
    "tagline": "Develop an algorithm to generate infinite, Minecraft-style 3D worlds using noise functions, and render them efficiently.",
    "domain": "Game Development & Graphics",
    "difficulty": "Advanced",
    "estimatedHours": 90,
    "problemStatement": "Creating large game worlds by hand is time-consuming. Procedural Content Generation (PCG) uses algorithms to create content on the fly. A key challenge is generating natural-looking terrain and rendering the massive number of resulting blocks (voxels) efficiently.",
    "solution": "Using a 3D graphics library like Three.js or a game engine like Godot, implement a world generation system. Use Perlin or Simplex noise functions to generate a heightmap. The world will be divided into 'chunks'. For each chunk, generate the voxel data and then create a mesh. You will need to implement an optimization like 'greedy meshing' or 'culling' to only render the visible faces of the voxels, drastically improving performance.",
    "skillsGained": ["Procedural Generation (PCG)", "3D Graphics", "Noise Algorithms (Perlin/Simplex)", "Voxel Engines", "Mesh Generation", "Performance Optimization"],
    "techStack": [{"name": "Three.js / Godot / Unity", "type": "Graphics/Engine"}, {"name": "JavaScript/C#/GDScript", "type": "Language"}, {"name": "GLSL (for shaders)", "type": "Shading Language"}],
    "professionalPractices": {"chunkingSystem": {"title": "Chunking System", "description": "Learn the standard technique for managing infinite worlds by breaking them into manageable, fixed-size chunks that can be loaded/unloaded as the player moves."}, "efficientMeshGeneration": {"title": "Efficient Mesh Generation", "description": "Tackle the primary performance bottleneck of voxel engines by implementing an algorithm (like greedy meshing) to reduce the number of vertices sent to the GPU."}, "layeredNoise": {"title": "Layered Noise Functions", "description": "Create more interesting and realistic terrain by combining multiple noise functions at different frequencies and amplitudes."}},
    "milestones": [
      {"id": "pcg_m1", "title": "Phase 1: Basic Voxel Rendering", "goal": "Render a single 16x16x16 chunk of solid cubes in a naive way, with one cube mesh per voxel. This will demonstrate the performance problem.", "content": [ { "type": "paragraph", "value": "This baseline will show you why optimization is necessary." } ] },
      {"id": "pcg_m2", "title": "Phase 2: Noise-Based Generation", "goal": "Use a 2D Perlin or Simplex noise function to determine the height of the terrain within a chunk, creating a landscape instead of a solid cube.", "content": [ { "type": "paragraph", "value": "The noise function's output at an (x, z) coordinate will determine the y-height of the terrain column." } ] },
      {"id": "pcg_m3", "title": "Phase 3: Greedy Meshing Optimization", "goal": "Implement a greedy meshing algorithm. Instead of rendering each cube, this algorithm iterates through the chunk and creates a single, optimized mesh by combining the visible faces of adjacent, same-type voxels into larger polygons.", "content": [ { "type": "paragraph", "value": "This is the most critical optimization step and will drastically reduce the number of vertices, leading to a huge performance gain." } ] },
      {"id": "pcg_m4", "title": "Phase 4: Infinite World and Chunk Management", "goal": "Create a system that tracks the player's position and dynamically loads/generates new chunks as they move, while unloading chunks that are far away. This creates the illusion of an infinite, seamless world.", "content": [ { "type": "paragraph", "value": "This involves managing the lifecycle of chunks in a grid around the player." } ] }
    ]
  },
  {
    "id": 31,
    "title": "Customer Segmentation with RFM Analysis",
    "tagline": "Analyze a transactional dataset to segment customers into meaningful groups based on their purchasing behavior, providing actionable insights for marketing.",
    "domain": "Data Analysis",
    "difficulty": "Intermediate",
    "estimatedHours": 35,
    "problemStatement": "Marketing teams need a data-driven way to identify their 'best' customers, 'at-risk' customers, and 'new' customers to tailor their marketing campaigns effectively.",
    "solution": "Using Python in a Jupyter Notebook, perform an RFM (Recency, Frequency, Monetary) analysis on an online retail dataset. You will calculate the recency, frequency, and monetary value for each customer. You will then use these metrics to assign customers to segments like 'Champions', 'At-Risk', and 'Lost'. Finally, create visualizations and a report summarizing each segment's characteristics and providing targeted marketing recommendations.",
    "skillsGained": ["Data Analysis", "Exploratory Data Analysis (EDA)", "Customer Segmentation", "RFM Analysis", "Data Visualization (Seaborn, Matplotlib)", "Business Acumen"],
    "techStack": [{"name": "Python", "type": "Language"}, {"name": "Pandas", "type": "Data Manipulation"}, {"name": "Seaborn", "type": "Visualization"}, {"name": "Jupyter Notebook", "type": "IDE"}],
    "professionalPractices": {"actionableInsights": {"title": "Generating Actionable Insights", "description": "Go beyond just creating segments. Learn to provide concrete business recommendations for each segment (e.g., 'Target Champions with a loyalty program')."}, "dataStorytelling": {"title": "Data Storytelling", "description": "Practice structuring your analysis as a narrative in a notebook, guiding the reader from the raw data to the final, impactful business conclusions."}, "quantitativeSegmentation": {"title": "Quantitative Segmentation", "description": "Learn a classic, powerful marketing analytics technique that is widely used in the industry to understand customer value."}},
    "milestones": [
      {"id": "da1_m1", "title": "Phase 1: Data Acquisition and Cleaning", "goal": "Load the transactional dataset, handle missing values, and convert data types correctly.", "content": [ { "type": "paragraph", "value": "We will use the 'Online Retail' dataset from the UCI Machine Learning Repository. You can download it directly." }, { "type": "callout", "style": "info", "value": "Dataset link: https://archive.ics.uci.edu/ml/datasets/online+retail" }, { "type": "code", "language": "python", "value": "import pandas as pd\n\ndf = pd.read_excel('Online Retail.xlsx')\n\n# --- Data Cleaning Steps ---\n# Drop rows with no CustomerID\ndf.dropna(subset=['CustomerID'], inplace=True)\n# Convert CustomerID to integer\ndf['CustomerID'] = df['CustomerID'].astype(int)\n# Ensure Quantity and UnitPrice are positive\ndf = df[(df['Quantity'] > 0) & (df['UnitPrice'] > 0)]\n# Create a TotalPrice column\ndf['TotalPrice'] = df['Quantity'] * df['UnitPrice']" } ] },
      {"id": "da1_m2", "title": "Phase 2: RFM Calculation", "goal": "Calculate the Recency, Frequency, and Monetary value for each unique customer.", "content": [ { "type": "paragraph", "value": "We need to transform the transactional data into a customer-level summary." }, { "type": "code", "language": "python", "value": "import datetime as dt\n\n# Set a snapshot date for recency calculation (day after the last transaction)\nsnapshot_date = df['InvoiceDate'].max() + dt.timedelta(days=1)\n\n# Aggregate data for each customer\nrfm = df.groupby('CustomerID').agg({\n    'InvoiceDate': lambda date: (snapshot_date - date.max()).days, # Recency\n    'InvoiceNo': 'nunique', # Frequency\n    'TotalPrice': 'sum' # Monetary\n})\n\n# Rename columns\nrfm.rename(columns={'InvoiceDate': 'Recency', 'InvoiceNo': 'Frequency', 'TotalPrice': 'MonetaryValue'}, inplace=True)" } ] },
      {"id": "da1_m3", "title": "Phase 3: Segmentation with Quantiles", "goal": "Create scoring rules based on RFM values to assign each customer to a specific segment.", "content": [ { "type": "paragraph", "value": "We will use quantiles to create four groups for each metric. For example, the 25% of most recent customers get the highest Recency score." }, { "type": "code", "language": "python", "value": "# Create labels for R, F, M\nrfm['R_score'] = pd.qcut(rfm['Recency'], 4, labels=[4, 3, 2, 1]) # Higher is better\nrfm['F_score'] = pd.qcut(rfm['Frequency'].rank(method='first'), 4, labels=[1, 2, 3, 4])\nrfm['M_score'] = pd.qcut(rfm['MonetaryValue'], 4, labels=[1, 2, 3, 4])\n\n# Combine scores\nrfm['RFM_Segment'] = rfm['R_score'].astype(str) + rfm['F_score'].astype(str) + rfm['M_score'].astype(str)" } ] },
      {"id": "da1_m4", "title": "Phase 4: Analysis and Reporting", "goal": "Analyze the size and value of each segment, create visualizations, and write a summary report with marketing recommendations.", "content": [ { "type": "paragraph", "value": "Labeling segments makes the analysis easier to communicate." }, { "type": "code", "language": "python", "value": "# Example: Find 'Champions'\nchampions = rfm[rfm['RFM_Segment'] == '444']\nprint(f'Number of Champion customers: {len(champions)}')\n\n# Visualize segment distribution\nimport seaborn as sns\nsns.countplot(x='R_score', data=rfm)\n" }, { "type": "paragraph", "value": "Your final report should include a summary table of key segments, their size, and recommended actions for each." } ] }
    ]
  },
  {
    "id": 32,
    "title": "Sales Forecasting with Time Series Analysis",
    "tagline": "Build and evaluate a time series model to forecast future sales for a retail business based on historical data.",
    "domain": "Data Analysis & Forecasting",
    "difficulty": "Advanced",
    "estimatedHours": 50,
    "problemStatement": "Businesses need to accurately forecast future sales for inventory management, resource planning, and financial budgeting. A reliable model is needed to capture trends, seasonality, and other patterns in historical data to make these predictions.",
    "solution": "Using a retail sales dataset, you will perform a complete time series analysis in Python. This involves decomposing the time series into its trend, seasonal, and residual components. You will test for stationarity using statistical tests (e.g., ADF test). You will then build a SARIMA (Seasonal AutoRegressive Integrated Moving Average) model to forecast sales for the next quarter. Finally, you will evaluate the model's accuracy by comparing its predictions on a hold-out test set.",
    "skillsGained": ["Time Series Analysis", "Forecasting", "SARIMA Models", "Statistical Modeling", "Data Visualization", "Model Evaluation"],
    "techStack": [{"name": "Python", "type": "Language"}, {"name": "Pandas", "type": "Data Handling"}, {"name": "statsmodels", "type": "Statistical Library"}, {"name": "Matplotlib", "type": "Plotting"}, {"name": "Jupyter Notebook", "type": "IDE"}],
    "professionalPractices": {"stationarityAndDifferencing": {"title": "Stationarity and Differencing", "description": "Understand the critical concept of stationarity in time series data and learn how to use differencing to make a series stationary, a prerequisite for many models."}, "modelDiagnostics": {"title": "Model Diagnostics", "description": "Learn to analyze the residuals of your model to check for patterns, ensuring the model's assumptions are met and it has captured all available information."}, "holdoutValidation": {"title": "Hold-Out Validation for Time Series", "description": "Practice the correct way to validate a time series model by training on the past and testing on the most recent data, avoiding data leakage."}},
    "milestones": [
      {"id": "da2_m1", "title": "Phase 1: Data Exploration and Decomposition", "goal": "Load and plot the time series data, and perform seasonal decomposition to identify trends and seasonality.", "content": [ { "type": "paragraph", "value": "We will use a sample Superstore Sales dataset, widely available on Kaggle." }, { "type": "callout", "style": "info", "value": "Dataset link: https://www.kaggle.com/datasets/rohitsahoo/sales-forecasting" }, { "type": "code", "language": "python", "value": "import pandas as pd\nfrom statsmodels.tsa.seasonal import seasonal_decompose\n\ndf = pd.read_csv('train.csv', parse_dates=['Order Date'], index_col='Order Date')\nmonthly_sales = df['Sales'].resample('MS').sum()\n\ndecomposition = seasonal_decompose(monthly_sales)\ndecomposition.plot()" } ] },
      {"id": "da2_m2", "title": "Phase 2: Stationarity Testing", "goal": "Test the series for stationarity using the Augmented Dickey-Fuller (ADF) test. Apply differencing if the series is non-stationary.", "content": [ { "type": "paragraph", "value": "Most time series models assume the data is stationary (i.e., its statistical properties do not change over time). We must test and enforce this." }, { "type": "code", "language": "python", "value": "from statsmodels.tsa.stattools import adfuller\n\nresult = adfuller(monthly_sales)\nprint(f'ADF Statistic: {result[0]}')\nprint(f'p-value: {result[1]}') # If p-value > 0.05, series is not stationary" } ] },
      {"id": "da2_m3", "title": "Phase 3: SARIMA Model Building", "goal": "Analyze ACF and PACF plots to determine the optimal parameters (p,d,q)(P,D,Q,m) for a SARIMA model and fit it to the training data.", "content": [ { "type": "paragraph", "value": "This is the core modeling step. We use auto-correlation and partial auto-correlation plots to guide our choice of model orders." }, { "type": "code", "language": "python", "value": "import statsmodels.api as sm\n\n# Example model order, real determination is more complex\nmodel = sm.tsa.statespace.SARIMAX(monthly_sales, order=(1, 1, 1), seasonal_order=(1, 1, 1, 12))\nresults = model.fit()" } ] },
      {"id": "da2_m4", "title": "Phase 4: Forecasting and Evaluation", "goal": "Use the trained model to make forecasts on a hold-out test set and evaluate its performance using metrics like Root Mean Squared Error (RMSE).", "content": [ { "type": "paragraph", "value": "We compare the model's predictions to the actual values to see how accurate it is." }, { "type": "code", "language": "python", "value": "from sklearn.metrics import mean_squared_error\nimport numpy as np\n\n# Split data into train and test\ntrain = monthly_sales[:-12]\ntest = monthly_sales[-12:]\n\n# Fit model on train, then predict for the same period as test\npredictions = results.get_prediction(start=pd.to_datetime('some_date'), dynamic=False)\n\nrmse = np.sqrt(mean_squared_error(test, predictions.predicted_mean))\nprint(f'RMSE: {rmse}')" } ] }
    ]
  },
  {
    "id": 33,
    "title": "Topic Modeling of Customer Reviews",
    "tagline": "Use Natural Language Processing (NLP) to analyze thousands of customer reviews and automatically discover the main topics of praise and complaint.",
    "domain": "Data Analysis & NLP",
    "difficulty": "Advanced",
    "estimatedHours": 45,
    "problemStatement": "Product managers need to understand what customers are saying, but manually reading thousands of reviews is impossible. An automated system is needed to sift through unstructured text data and identify the key recurring themes.",
    "solution": "Using a dataset of customer reviews (e.g., Amazon product reviews), you will build an NLP pipeline in Python. This involves: text cleaning and preprocessing (removing stopwords, lemmatization); vectorizing the text using TF-IDF; and applying Latent Dirichlet Allocation (LDA) to discover a set of topics. You will then analyze the words associated with each topic to label them (e.g., 'Shipping', 'Quality', 'Service') and create a report for business stakeholders.",
    "skillsGained": ["Natural Language Processing (NLP)", "Topic Modeling (LDA)", "Text Preprocessing", "Feature Extraction (TF-IDF)", "Unsupervised Learning", "Data Visualization (pyLDAvis)"],
    "techStack": [{"name": "Python", "type": "Language"}, {"name": "NLTK / SpaCy", "type": "NLP Library"}, {"name": "Scikit-learn", "type": "ML"}, {"name": "Gensim", "type": "Topic Modeling"}, {"name": "pyLDAvis", "type": "Visualization"}],
    "professionalPractices": {"unstructuredToStructured": {"title": "Unstructured to Structured Data Conversion", "description": "Master the fundamental NLP task of converting messy, unstructured text into a structured numerical format (like TF-IDF vectors) that machine learning models can understand."}, "unsupervisedDiscovery": {"title": "Unsupervised Topic Discovery", "description": "Learn the power of unsupervised learning to find hidden patterns in data without pre-existing labels, a common real-world business problem."}, "modelInterpretation": {"title": "Model Interpretation and Labeling", "description": "Practice the crucial 'human-in-the-loop' skill of interpreting the output of an algorithm (the word clusters from LDA) and applying meaningful business labels to them."}},
    "milestones": [
      {"id": "da3_m1", "title": "Phase 1: Text Cleaning and Preprocessing", "goal": "Write a pipeline to clean the raw review text, including lowercasing, stopword removal, and lemmatization.", "content": [ { "type": "paragraph", "value": "We will use a dataset like 'Amazon Fine Food Reviews' from Kaggle." }, { "type": "callout", "style": "info", "value": "Dataset link: https://www.kaggle.com/datasets/snap/amazon-fine-food-reviews" }, { "type": "code", "language": "python", "value": "import nltk\nfrom nltk.corpus import stopwords\nfrom nltk.stem import WordNetLemmatizer\n\nstop_words = set(stopwords.words('english'))\nlemmatizer = WordNetLemmatizer()\n\ndef preprocess(text):\n    tokens = nltk.word_tokenize(text.lower())\n    return [lemmatizer.lemmatize(w) for w in tokens if w.isalpha() and w not in stop_words]" } ] },
      {"id": "da3_m2", "title": "Phase 2: Vectorization", "goal": "Convert the cleaned text into a document-term matrix using Scikit-learn's TfidfVectorizer.", "content": [ { "type": "paragraph", "value": "This step represents the importance of each word in each document, preparing it for the LDA model." }, { "type": "code", "language": "python", "value": "from sklearn.feature_extraction.text import TfidfVectorizer\n\nvectorizer = TfidfVectorizer(max_df=0.95, min_df=2, tokenizer=preprocess)\ntfidf_matrix = vectorizer.fit_transform(df['Text'])" } ] },
      {"id": "da3_m3", "title": "Phase 3: Topic Modeling with LDA", "goal": "Train a Latent Dirichlet Allocation (LDA) model on the document-term matrix to identify a specified number of topics.", "content": [ { "type": "paragraph", "value": "LDA is an unsupervised algorithm that will find clusters of co-occurring words, which represent the topics." }, { "type": "code", "language": "python", "value": "from sklearn.decomposition import LatentDirichletAllocation\n\nlda = LatentDirichletAllocation(n_components=10, random_state=42)\nlda.fit(tfidf_matrix)" } ] },
      {"id": "da3_m4", "title": "Phase 4: Interpretation and Visualization", "goal": "Analyze the top words for each topic to give them meaningful labels (e.g., 'Coffee & Flavor', 'Pet Food', 'Shipping Issues'). Use pyLDAvis to create an interactive visualization of the topics.", "content": [ { "type": "paragraph", "value": "This is the final, crucial step where you translate the model's output into business insights." }, { "type": "code", "language": "python", "value": "def print_top_words(model, feature_names, n_top_words):\n    for topic_idx, topic in enumerate(model.components_):\n        message = f'Topic #{topic_idx}: '\n        message += ' '.join([feature_names[i] for i in topic.argsort()[:-n_top_words - 1:-1]])\n        print(message)\n\nprint_top_words(lda, vectorizer.get_feature_names_out(), 10)" } ] }
    ]
  }
]